<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据分析系列-1</title>
    <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-1/"/>
    <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据分析第一课-数据分析过程与方法论"><a href="#一、数据分析第一课-数据分析过程与方法论" class="headerlink" title="一、数据分析第一课-数据分析过程与方法论"></a>一、数据分析第一课-数据分析过程与方法论</h1><a id="more"></a><h2 id="1-数据分析六部曲"><a href="#1-数据分析六部曲" class="headerlink" title="1.数据分析六部曲"></a>1.数据分析六部曲</h2><p>数据分析基本过程：数据收集-数据处理-根据分析目的和思路进行数据分析-分析结果图标展示-撰写分析报告    </p><h2 id="2-数据分析方法论"><a href="#2-数据分析方法论" class="headerlink" title="2.数据分析方法论"></a>2.数据分析方法论</h2><hr><p>方法论就是指导进行数分析的方法，你的数据分析需要有理论基础来支撑，这就是方法论。<br>常用的方法论有：<br>营销方面：4P、用户使用行为、STP理论、SWOT理论等<br>管理方面：PEST、5W2H、时间管理、生命周期、逻辑树、金字塔、SMART原则等。</p><h3 id="2-1-PEST分析法"><a href="#2-1-PEST分析法" class="headerlink" title="2.1 PEST分析法"></a>2.1 PEST分析法</h3><p>PEST分析法主要针对宏观环境的分析<br>就是对政治、经济、技术和社会这四大类外部环境因素进行分析。<br><img src="/img/pest.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-2-5W2H分析法"><a href="#2-2-5W2H分析法" class="headerlink" title="2.2 5W2H分析法"></a>2.2 5W2H分析法</h3><p>5W2H方法可以用在当你逻辑不清晰时，可用这几个方面来进行分析。<br>何因、何事、何时、何人、何地、如何做、何价 这七个方面进行分析。<br><img src="/img/5w2h.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-逻辑树分析法"><a href="#2-3-逻辑树分析法" class="headerlink" title="2.3 逻辑树分析法"></a>2.3 逻辑树分析法</h3><p>逻辑树分析法用在当一个问题比较明确，期望通过分析来找到问题所在，解决关键问题。<br>就是将引起一个问题的原因进行一级一级的罗列，进行拆分。<br><img src="/img/luojishu.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-4-4P营销理论"><a href="#2-4-4P营销理论" class="headerlink" title="2.4 4P营销理论"></a>2.4 4P营销理论</h3><p>4P营销理论主要运用在了解公司整体运营情况上，以此来搭建公司整体运行框架<br>就是通过分析公司产品、价格、渠道、促销来分析公司目前的运营状况。<br><img src="/img/4p.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-5-用户行为理论"><a href="#2-5-用户行为理论" class="headerlink" title="2.5 用户行为理论"></a>2.5 用户行为理论</h3><p>用户行为理论是指用户对一个产品从认知、熟悉、试用、使用、忠诚的过程理论，对于一件产品或者一个网站，如果不清楚它目前在人群中的定位，就可以使用此理论。比如一个网站，目前他的ip、pv量指标很大但是平均停留市场很短，说明就是在认知阶段；如果平均停留时长很长，但注册用户并不多，说明是在熟悉阶段，，，以此类推，可以通过用户行为，找到产品在用户人群中的定位。如下图网站例子所示<br><img src="/img/yonghuxingwei.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、数据分析第二课-数据准备"><a href="#二、数据分析第二课-数据准备" class="headerlink" title="二、数据分析第二课-数据准备"></a>二、数据分析第二课-数据准备</h1><p>常言道，巧妇难为无米之炊，要想数据分析，首先要进行数据准备。</p><h2 id="1-理解数据"><a href="#1-理解数据" class="headerlink" title="1.理解数据"></a>1.理解数据</h2><h3 id="1-1字段与记录"><a href="#1-1字段与记录" class="headerlink" title="1.1字段与记录"></a>1.1字段与记录</h3><p>字段是事物或者现象的某种特征，比如学号、名字，在统计学中称为变量<br>记录是事物或现象某种特征的具体体现，比如成绩是“85”，性别为“男”，记录也称为数据或变量值。<br>字段和记录就是键值对的关系。</p><h3 id="1-2数据类型"><a href="#1-2数据类型" class="headerlink" title="1.2数据类型"></a>1.2数据类型</h3><p>数据类型总体有两种，字符型和数值型</p><h3 id="1-3数据表"><a href="#1-3数据表" class="headerlink" title="1.3数据表"></a>1.3数据表</h3><p>一维表和二维表，如图<br>区分一维表和二维表：一维表中的数值，如2006、2007等都是属于字段“年份”的，也就是说，同一列的数据，从第二行开始往下的数据都是属于第一行的范畴的，比如“北京”属于“地区”；而二维表7861，不属于“2006”，也不属于“北京”，而是同时代表了“2006”年的“北京”的Gdp，同时代表的三样事物。这就是区别，如下图<br><img src="/img/yiweierweibiao.png" srcset="/img/loading.gif" alt=""><br>具体怎么实现一维表和二维表的转换，百度就行</p><h1 id="三、数据处理"><a href="#三、数据处理" class="headerlink" title="三、数据处理"></a>三、数据处理</h1><p>由于《谁说菜鸟不会数据分析》这本书都是用excel做的，所以这本书就没有多大学习的必要了。下一阶段就从数据处理就是学习pandans了</p>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>birthday</title>
    <link href="/2020/03/24/birthday/"/>
    <url>/2020/03/24/birthday/</url>
    
    <content type="html"><![CDATA[<p>生日快乐，张弟弟!</p><a id="more"></a><p>今天,23了，他们说<br>23和24是完全不同的两个年龄，23可能啥也不知道，24就感觉时间飞逝了，毕竟活了整整两个轮回了呢<br>大家都在好好的工作了，终于到了自己找工作的时候了，有点怕，也有点期待。<br>向着自己喜欢的职业，还是有时间在努力一下的呢<br>嗝~<br>今天吃的有点饱，一会出去打会球吧<br>张弟弟，你要加油啊<br>加油变强，变帅，变的更加无所畏惧<br>这是你的第24年了，加油！<br>打会球，回来再keep吧，<br>冲啊<br>张弟弟！！！！！！！！！！！！！！！！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>daily life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test1</title>
    <link href="/2020/03/23/test1/"/>
    <url>/2020/03/23/test1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>newlife</title>
    <link href="/2020/03/11/newlife/"/>
    <url>/2020/03/11/newlife/</url>
    
    <content type="html"><![CDATA[<p>我分手了，谈了咋算也有四年了的恋爱，结束了。。。</p><a id="more"></a><p>思索良久，考虑再三，决定和你了分手，对不起，几年的异地，我输在了终点。<br>你说，我为啥呢，我凭啥呢？我也不知道啊，你给了我青春，我又何尝不是呢，我跟之前那么要好的朋友的都不联系了，<br>我，早已不再是我了<br>说实话，这几年，我从来没有深深的反思过自己，堕落如此，为何？<br>不是因为你，是因为我，我太在意你，太在意爱的人，我都忘了我自己了，我都忘了，最该爱的，除了父母亲人，本应该是自己了<br>你给了我青春，我也给了你的，爱你时，我用尽全力，可是，我得到了什么呢<br>相信分手后，大家都会骂我渣男的，是的，我是很渣，是的吧，天生的我也没办法<br>忽然有一天，哪一天呢？记不清了，大概是她考完研的某天<br>我看了一下自己，遍体鳞伤，为什么呢<br>这么多年了，我都没好好的爱自己啊，<br>我太重视在乎的人感受了，<br>其实<br>真的是不值得啊<br>哈哈<br>谈着恋爱，心里却始终是感觉一个人，我问过自己，我也给了自己答案，可能你不太会爱一个人吧，可能我也不会吧<br>爱你时候很爱，心无旁骛，因为心太满，都是你，但是当我看见别的情侣之间那种感觉，我愣住了，我这几年是在谈恋爱么，，，<br>这次<br>心<br>真的累了<br>对不起，没有给你甜甜的恋爱，我太直了，<br>我想好好爱一下自己，不然以后有了自己的家，更没时间爱自己了，哈哈<br>对不起啊，家里可能没有你了，你要好好的啊</p><p>还是决定重启我的博客，多多审视自己的内心，希望坚持下去，人那，毕竟是自己活着，<br>敬自己！</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlday1</title>
    <link href="/2019/10/31/mlday1/"/>
    <url>/2019/10/31/mlday1/</url>
    
    <content type="html"><![CDATA[<p>机器学习入门</p><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h2 id="略略略"><a href="#略略略" class="headerlink" title="略略略"></a>略略略</h2><p>字典特征值转化为二维数组/矩阵<br>首先需要知道得到的结果是value而不是key，key在结果中并没有显示。而在此处，二者分别用特征名和特征值来代替。<br>-先用两个字典，他们的value都是数字：</p><pre><code>    dic1 = [{&#39;地区&#39;:100,&#39;温度&#39;:200},{&#39;地区&#39;:200,&#39;温度&#39;:400}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[100. 200.]     [200. 400.]]</code></pre><p>可以看到，他将字典的value值，通过矩阵或者说二维数组的形式表示出来了。<br>-再将字典的value变成字符串：</p><pre><code>    dic1 = [{&#39;1&#39;:&#39;100&#39;,&#39;温度&#39;:200},{&#39;1&#39;:&#39;200&#39;,&#39;温度&#39;:400}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[  1.   0. 200.]     [  0.   1. 400.]]</code></pre><p>可以看到，后面的200、400仍然不变，但是前面的string的value值被两个1hot编码给代替了，<br>-再将后面的value值也变成字符串：</p><pre><code>    dic1 = [{&#39;1&#39;:&#39;100&#39;,&#39;温度&#39;:&#39;200&#39;},{&#39;1&#39;:&#39;200&#39;,&#39;温度&#39;:&#39;400&#39;}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[1. 0. 1. 0.]     [0. 1. 0. 1.]]</code></pre><p>结果是两个value都变成了1hot编码来代替。<br>就是，当特征值为类别（string）时，就会使用1hot编码。<br>-前面输出的都是特征值，下面输出特征名字：</p><pre><code>        dic1 = [{&#39;数字&#39;:&#39;100&#39;,&#39;温度&#39;:200},{&#39;数字&#39;:&#39;200&#39;,&#39;温度&#39;:400}]        transfer1 = DictVectorizer(sparse=False)        data1 = transfer1.fit_transform(dic1)        #print(&quot;全是数字的特征:\n&quot;,data1)        print(&quot;特征名字：\n&quot;,transfer1.get_feature_names())    结果：        全是数字的特征:         [[  1.   0. 200.]         [  0.   1. 400.]]        特征名字：         [&#39;数字=100&#39;, &#39;数字=200&#39;, &#39;温度&#39;]</code></pre><p>从名字可以看出，第一列表示“数字=100”，如果你是，就是1；不是，就是0；第二列表示“数字=200”；第三列表示“温度”。以此类推。。。<br>文本特征值转化二位数组</p><hr><p>就是将一段文本的每个单词作为一个特征，统计该单词出现的次数</p><pre><code>    data = [&#39;life is short,i like like python&#39;,&#39;life is too long ,i dislike python&#39;]    transfer = CountVectorizer()    datanew = transfer.fit_transform(data)    print(&quot;运行结果:\n&quot;,datanew.toarray())    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())结果：    运行结果:     [[0 1 1 2 0 1 1 0]     [1 1 1 0 1 1 0 1]]    特征名字：     [&#39;dislike&#39;, &#39;is&#39;, &#39;life&#39;, &#39;like&#39;, &#39;long&#39;, &#39;python&#39;, &#39;short&#39;, &#39;too&#39;]</code></pre><p>中文文本特征</p><pre><code>    data = [&#39;人生苦短,啦啦啦&#39;,&#39;我我用Python&#39;]    transfer = CountVectorizer()    datanew = transfer.fit_transform(data)    print(&quot;运行结果:\n&quot;,datanew.toarray())    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())结果：    运行结果:     [[1 1 0]     [0 0 1]]    特征名字：     [&#39;人生苦短&#39;, &#39;啦啦啦&#39;, &#39;我我用python&#39;]</code></pre><p>可以看到中文文本的结果依据逗号来断句，哈哈哈哈哈。然后介绍一个自动中文分词的库，jieba，可以根据中文的词组规范，自动进行分词，比如“我爱北京天安门”—&gt;“我 爱 北京 天安门”，然后在输出特征就可以了。</p><pre><code>        data = [&#39;我爱北京天安门&#39;, &#39;我和我亲爱的祖国&#39;]        new_list = []        for i in data:            data1 = &quot; &quot;.join(list(jieba.cut(i)))            new_list.append(data1)        print(new_list)    结果：        [&#39;我 爱 北京 天安门&#39;, &#39;我 和 我 亲爱 的 祖国&#39;]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又是建模的一天</title>
    <link href="/2019/10/19/%E5%8F%88%E6%98%AF%E5%BB%BA%E6%A8%A1%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <url>/2019/10/19/%E5%8F%88%E6%98%AF%E5%BB%BA%E6%A8%A1%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>今天也是建模的一天，但是呢，出现了很大的问题，我也不知道这个问题是不是由于人为因素出现的，但是呢，还是好难受啊。<br>跟室友喝了顿酒，还是好多了。<br>为什么总是觉得做的不够，大概是因为心中有所期待吧。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池的join用法</title>
    <link href="/2019/10/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0join%E7%94%A8%E6%B3%95/"/>
    <url>/2019/10/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0join%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>承接上篇关于线程池的join用法  ^_^   这图真不错，竟然也成了找图专业户了</p><a id="more"></a><h2 id="threading线程池"><a href="#threading线程池" class="headerlink" title="threading线程池"></a>threading线程池</h2><p>今天一直在查关于线程池的用法，因为线程池是创建线程之后，当不使用的时候就放在线程池里面而不会销毁，相比于创建线程又销毁线程减少了不少时间。但是搜了好多，试了好多，依然没有啥具体的结果。<br>但是搜到了一篇threading+queue创建线程池的做法，就是上一盘文章的用法，所以本文对其进行扩充，主要为增加join的用法。</p><ol><li><p>没有加入join结果：</p><pre><code> import time from fake_useragent import UserAgent as ua import requests from queue import Queue import threading def get_url(url_queue):     while url_queue.qsize() &gt; 0:         url =  url_queue.get()         headers = {&quot;User-Agent&quot;: ua().Chrome}         response = requests.get(url=url, headers=headers, timeout=10)         print(threading.current_thread().name)         print(&quot;访问了：&quot;,url) def get_queue():     url_queue = Queue()     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://www.baidu.com&quot;,                 &quot;http://www.jd.com&quot;,                 &quot;http://www.sina.com&quot;,                 &quot;http://zzzspider.top&quot;,                 ]     for url in url_list:         url_queue.put(url)     return url_queue if __name__ == &#39;__main__&#39;:     print(threading.current_thread().name)     url_queue = get_queue()     for i in range(3):         th = threading.Thread(target=get_url,args=(url_queue,))         th.start()     print(&quot;task done&quot;)</code></pre><p>运行结果：</p><pre><code> MainThread task done Thread-3 访问了： http://www.jd.com Thread-3 访问了： http://www.sina.com Thread-2 访问了： http://www.baidu.com Thread-1 访问了： http://film.qq.com Thread-3 访问了： http://zzzspider.top</code></pre><p>可以看出，想在所有线程结束之后打印出task done的作用没有实现，因为主线程不管子线程，只要运行结束就结束了，但是此时子线程仍然在运行，所以打印内容随着主线程结束之后就输出了。</p></li><li><p>加入join()第一次尝试：仅修改主函数部分</p><pre><code> if __name__ == &#39;__main__&#39;:     print(threading.current_thread().name)     url_queue = get_queue()     for i in range(3):         th = threading.Thread(target=get_url,args=(url_queue,))         th.start()         th.join()     print(&quot;task done&quot;)</code></pre><p>运行及结果：</p><pre><code> MainThread Thread-1 访问了： http://film.qq.com Thread-1 访问了： http://www.baidu.com Thread-1 访问了： http://www.jd.com Thread-1 访问了： http://www.sina.com Thread-1 访问了： http://zzzspider.top task done</code></pre><p>虽然实现了task done在主线程结束之后在输出， 但是可以看出此时只有一个线程在执行。。</p></li><li><p>第二次尝试：</p><pre><code> for i in range(3):     th = threading.Thread(target=get_url,args=(url_queue,))     th.start() th.join()</code></pre><p>这次运行结果就可以了，但是多运行了几次之后发现，仍然会偶发性的产生主线程较早结束的情况。</p></li><li><p>创建一个线程池函数，然后在主线程中调用：</p><pre><code> import time from fake_useragent import UserAgent as ua import requests from queue import Queue import threading def get_url(url_queue):     while url_queue.qsize() &gt; 0:         url =  url_queue.get()         headers = {&quot;User-Agent&quot;: ua().Chrome}         response = requests.get(url=url, headers=headers, timeout=10)         print(threading.current_thread().name)         print(threading.current_thread().is_alive())         print(&quot;访问了：&quot;,url) def get_queue():     url_queue = Queue()     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://www.baidu.com&quot;,                 &quot;http://www.jd.com&quot;,                 &quot;http://www.sina.com&quot;,                 &quot;http://zzzspider.top&quot;,                 ]     for url in url_list:         url_queue.put(url)     return url_queue def th_list():     th_list = []     for i in range(4):         th = threading.Thread(target=get_url,args=(url_queue,))         th_list.append(th)     return th_list if __name__ == &#39;__main__&#39;:     for i in range(10):         print(threading.current_thread().name)         url_queue = get_queue()         th_list1 = th_list()         for th in th_list1:             th.start()         th.join()         print(&quot;task done&quot;)         print(th.is_alive())</code></pre><p>运行结果，比3好多了，但是！！！还有很小概率的出现那个情况。。。。属实不知道为什么。。。</p></li><li><p>终极版<br>修改4的代码：</p><pre><code> if __name__ == &#39;__main__&#39;:     for i in range(10):         print(threading.current_thread().name)         url_queue = get_queue()         th_list1 = th_list()         for th in th_list1:             th.start()         for th in th_list1:             th.join()         print(&quot;task done&quot;)         print(th.is_alive())</code></pre><p>然后循环了10次，没出现错误的情况，，，虽然成功了，但是不知道为什么。。。懵逼中</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>join用法</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于threading多线程与tomorrow协程爬虫的一些对比</title>
    <link href="/2019/10/14/1014.html/"/>
    <url>/2019/10/14/1014.html/</url>
    
    <content type="html"><![CDATA[<p>记录一下threading构造多线程请求的基本语法，以及关于tomorrow协程爬虫的基本语法，并且对比一下二者的效率^…^,</p><a id="more"></a><hr><h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><ol><li><p>刚开始使用threading的时候与requests配合使用，但是每次都会出现重复请求的情况，就是虽然产生了多线程执行，但是每次多线程都请求相同的内容，最终发现是因为使用for循环来获取一个list中的url出的问题。不应该直接在list中获取url，而是先将list遍历存入到队列queue中，因为queue是一个队列，存在先入先出原则，而且等于说第一个数被拿出去了，就没有了，你再从中取值的话，就只能取第二个数，所以这样就使得不会产生重复的情况。下面是实现的语法。</p></li><li><p>threading+requests的用法：<br>(1) 首先需要定义一个队列函数：</p><pre><code> def url_queue():     list = [1,2,....]     for i in url_list:         url_queue.put(i) return url_queue</code></pre><p>结果可以得到一个队列：url_queue<br>(2) 定义一个requests函数：</p><pre><code> def get_html(url_queue):     while url_queue.qsize() &gt; 0:         url = url_queue.get()         response = requests.get(url=url,headers = headers,timeout = 10)         response.encoding = &#39;utf-8&#39;         response = response.text         print(response)     print(&quot;总用时:&quot;,time.time()-star_time)       #测试运行时间</code></pre><p>注意几个点：1是队列循环while，当然用for理论上也可以的，然后是编码问题。当我print网页内容时候，发现中文乱码，原因是网站的编码格式和Python解释器的格式不一样造成的，所以可以将responds进行编码’utf-8’，然后就可以输出内容了。<br>(3) 定义一个线程函数：</p><pre><code> def th_list():     thr_list = []     for i in range(5):         t_get = threading.Thread(target=get_html,args=(url_queue,))         thr_list.append(t_get)     return thr_list</code></pre><p>这一步的目的就是要构建一个线程的列表，以便于一会主函数调用，注意在targ参数中传入函数名，args参数中传入变量。<br>(4) 主函数：</p><pre><code> if __name__ == &#39;__main__&#39;:     star_time = time.time()   #测定运行时间     url_queue = url_queue()   #得到url队列     thr_list = th_list()      #调用创建线程函数，此时创建了一个具有n个线程的线程列表     for th in thr_list:          #遍历线程，实际上多线程就发生在这一步中，当上一个线程io操作时，         th.start()              #就会调用线程列表中的其他闲置线程运行。</code></pre><p>(5) 完整代码如下：</p><pre><code> import threading import requests from fake_useragent import UserAgent as ua from queue import Queue import time #coding:utf-8 headers = {&quot;User-Agent&quot;: ua().Chrome} url_queue = Queue() def get_url():     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://film.qq.com&quot;,                 &quot;http://film.qq.com&quot;,                 ]     for i in url_list:         url_queue.put(i)     return url_queue def get_html(url_queue):     while url_queue.qsize() &gt; 0:         url = url_queue.get()         response = requests.get(url=url,headers = headers,timeout = 10)         response.encoding = &#39;utf-8&#39;         response = response.text         print(response)     print(&quot;总用时:&quot;,time.time()-star_time) def th_list():     thr_list = []     for i in range(2):         t_get = threading.Thread(target=get_html,args=(url_queue,))         thr_list.append(t_get)     return thr_list if __name__ == &#39;__main__&#39;:     star_time = time.time()     url_queue = get_url()     thr_list = th_list()     for th in thr_list:         th.start()</code></pre></li></ol><hr><h2 id="tomorrow协程爬虫"><a href="#tomorrow协程爬虫" class="headerlink" title="tomorrow协程爬虫"></a>tomorrow协程爬虫</h2><h2 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h2><p>首先我们得知道协程是啥？协程其实可以认为是比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。</p><p>通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定<br>协程与线程？</p><hr><p>那么这个过程看起来比线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。<br>                                 （摘自—<a href="https://aceld.gitbooks.io/python/content/fu-wu-qi-mo-xing/xie-cheng.html）" target="_blank" rel="noopener">https://aceld.gitbooks.io/python/content/fu-wu-qi-mo-xing/xie-cheng.html）</a><br>通俗来讲，协程是线程的细分，实现功能和多线程差不多，(在深入理解日后再说）但是协程创建时间相比线程少，所以更加高效。<br>tomorrow</p><hr><p>实现代码如下：</p><pre><code>    import time    from requests_html import HTMLSession    from fake_useragent import UserAgent as ua    from tomorrow import threads    headers = {&quot;User-Agent&quot;: ua().Chrome}    session = HTMLSession()    url_list = [&quot;http://film.qq.com&quot;,                &quot;http://film.qq.com&quot;,]    @threads(2)    def async_get_req(url, timeout=10):        try:            req = session.get(url, headers=headers, timeout=timeout)            return req        except:            pass    def get_link(req_list):        for req in req_list:            try:                print(req.html.text)            except:                pass    if __name__ == &#39;__main__&#39;:        start2 = time.time()        req_list = []        for url in url_list:            req = async_get_req(url)            req_list.append(req)        get_link(req_list)        end2 = time.time()        print(&quot;并发后花费时间&quot;, end2 - start2)</code></pre><p>在构建过程中，唯一出现的问题就是，如果将上述两个函数合并为一个函数的话，协程就不会生效：</p><pre><code>    req_list = []        for url in url_list:            req = async_get_req(url)            req_list.append(req)            print(req.html.links)  #就是删除get_link函数，使其在此处实现，结果是不能协程执行，函数一个一个执行</code></pre><p>之后进行修改：</p><pre><code>    req_list = []    for url in url_list:        req = async_get_req(url)        req_list.append(req)            for i in req_list：                print(req.html.links)</code></pre><p>竟然就可以工作了，不知道为什么。。。<br>注意的地方就是，要创建多少线程，只要在函数前添加   @threads(2)  即可，方便，简单，高效。还有就是引入from requests_html import HTMLSession这个库，可以直接在网页获取之后就将其解析出来。十分方便。<br>最后通过运行时间对比，发现当线程数量和协程数量调大之后，多线程运行效率高于协程；而数量较小时候，协程效率高于多线程。灵活运用喽。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>多线程</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程与多进程</title>
    <link href="/2019/10/07/1007duoxiancheng.html/"/>
    <url>/2019/10/07/1007duoxiancheng.html/</url>
    
    <content type="html"><![CDATA[<p>关于Python多线程与多进程的一些自己理解的想法</p><a id="more"></a><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。<br>什么是线程？</p><hr><p>线程是指进程内的一个执行单元,也是进程内的可调度实体. 线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>看不太懂吧。可以做一个比喻，进程就是我们打开了一个ＱＱ，然后我们可以同时发消息，同时看空间，这就是多个线程。即进程是由系统调度的基本单位，而线程是进程内的执行单元。<br>进程和线程的发展史</p><hr><p>１.单进程，最初计算机是为了执行代码，就是每次只能执行一个程序，只有当这个程序执行完毕，才能执行下一个，比如要是聊ＱＱ就不能听歌。</p><p>２.多进程，为了提高使用效率，充分利用ｃｐｕ，就将内存划分成不同的块，每一个块就是一个进程，不同的程序放在不同的块里面，那么怎么能让这些程序同时执行呢？这就出现了“时间片轮转调度”，就是对于不同的进程，为其分配一个时间段，称为时间片，即该进程允许的时间。而ｃｐｕ呢就在这几个进程之间不断切换，很明显的是这几个进程也不是并行执行（也就是同时执行）的，但是对于ｃｐｕ来说，他的运算速度太快了，进程之间的切换快的对于人来说根本不可能察觉的到，所以对于人来说，在一秒内这几个进程都在执行，但实际上是ｃｐｕ在这一秒内对每个进程都执行了成百次的执行，才使得看起来同时执行。</p><p>３.多线程，时间片轮转调度是基于进程进行的，但是每个进程之下还可以进行细分。比如说我们打开一个ＱＱ，不仅可以聊天也可以看空间；所以对于进程又进行了细分：线程，这样一来ｃｐｕ的时间片轮转相当于又进行了细分，更加细腻，对每个线程划分时间片，ｃｐｕ在线程之间切换，使得运行更加丝滑，此时ｃｐｕ实际上是在线程之间进行切换。</p><p>４.多核，在计算上提高运行之后，越来越需要大量的计算，ｃｐｕ甚至有点不够用，此时影响的主要是硬件的能力，所以就发明了多核ｃｐｕ，每个核心可以相当于一个ｃｐｕ，独自执行一个或多个进程，当然同时就只有一个线程。这样才实现了实际意义上的并行执行。</p><p>5.对于多核ｃｐｕ来说，如果是<strong>计算密集型</strong>的使用多线程时计算速度比较快；如果是<strong>ＩＯ密集型</strong>的多线程的作用是当进程ｉｏ运算时的等待时间可以被其他线程使用，比如执行某个程序，程序运行过程，我们可以看到进度条也在增加。</p><p>6.何时使用多线程：切换线程和创建线程是需要时间的，当运算量较大，切换线程的时间可以被多线程运算节省的时间所填补，就是值得的，如果运算量较小，添加线程的时间大于运算节省的时间就是不合适的；但是对于特殊的ｉｏ操作，需要较多的等待时间，此时创建一个线程或者切换的时间将远远小于让线程等待的时间，所以此时让ｃｐｕ为其他线程服务，就可以充分的利用资源了。<br>Ｐｙｔｈｏｎ多线程和多进程</p><hr><p>Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。<br>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。<br>1.设置GIL。<br>2.切换到一个线程去执行。<br>3.运行。<br>4.把线程设置为睡眠状态。<br>5.解锁GIL。<br>6.再次重复以上步骤。<br>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。<br>Python多线程</p><hr><p>所以对于Ｐｙｔｈｏｎ程序来说，每时每刻都只有一个线程在执行，可以说对于多核ｃｐｕ来说完全没有发挥作用。如果没有必要的话，开启多线程反而会减少运行效率，为什么呢？比如说算一个程序１００００次，只用一个线程的话就是一万次计算；但是开启多线程的话，每运算１００次就会切换一个线程，在切换过程中呢，就会发生上述六个步骤，这时间增加量可想而知，所以对于Ｐｙｔｈｏｎ来说，如果是需要进行大量计算得话尽量不要使用多线程。<br>如果程序中需要大量ｉｏ操作，并且开启多线程的话，在Ｐｙｔｈｏｎ中当进行ｉｏ操作之前会主动释放ｇｉｌ，然后在某线程ｉｏ操作执行中，其他线程就可以获得ｇｉｌ，就可以执行其他程序。也就是说，当进程中出现需要等待（被动或者主动）程序的话，比如执行１次，等待１ｓ，再执行一次，等待一秒，一共重复五次，如果是单线程，共需要等待５ｓ；如果是多线程，在第一次等待的１ｓ里面，第二次执行，并且进行等待，第三次也在执行，并进行等待。。。五次运行，所有过程紧接在上一次运行后面进行，运行时间远远小于等待时间，也就是相当于５次同时执行，同时等待。这就等于单线程时间的１/５，以此来提升效率。<br>所以，如果是ｉｏ操作，等待时间较多的话，Ｐｙｔｈｏｎ多线程能够发挥较好的作用，并且多线程创建比多进程容易的多，所以建议用多线程。<br>Python多进程</p><hr><p>Ｐｙｔｈｏｎ还有一种提速，就是创建多进程。相当于将某个进程进行复制，然后创建一个新的进程来同时执行，这样的话，基本上可以是的计算能力翻倍，但是相应的创建进程时间远大于创建线程时间。<br>如果某个程序计算需求非常大，创建一个多进程可以有效的提高计算效率，此时创建多进程花费的时间就可以被提高的效率覆盖，此时合适。但是如果程序不需要太多的计算能力，创建多进程花费的时间反而小于带来的收益，此时是不合适的。<br>所以多ｉｏ操作的程序，基本上不会创建多进程；多计算能力的，多考虑多进程<br>总结</p><hr><p>Ｐｙｔｈｏｎ多ｉｏ操作，或者等待，使用多线程可以很好的提高效率，因此使用多线程可以很好的提高爬虫的运行效率（因为访问网页，下载网页，存储，上传等ｉｏ过程中，都会发生等待）<br>多计算密集型操作，使用多进程可以很好的提高效率<br>一定量的计算密集型操作，考虑创建销毁多进程花费的时间与带来的效率提升做对比，来选择是否创建多进程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>多线程多进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十一小结</title>
    <link href="/2019/10/07/1007suibi.html/"/>
    <url>/2019/10/07/1007suibi.html/</url>
    
    <content type="html"><![CDATA[<p>十一过完了，对近几天情况做一下总结吧，也对这几天没更新做一下jiantao-_-</p><a id="more"></a><p>十一那天，在哈汽看的阅兵，因为老师的项目比较紧，所以我们的工作时间就是放假和星期天。除了十月二号在实验室呆了一天，研究那个评论和阅读量统计，搞了整整一天，硬是没弄明白，头都要炸了。索性就全删了，啥也不弄了，就写点东西记录自己的心得体会，也作为一个自我纠错自我复习的静谧之地啪~<br>在这几天里，实际上一直想弄明白Python的多线程为什么那么鸡肋，但是一直没有时间，整整的二号一天时间都被可恶的评论统计给整没了，郁闷至极。然后其他时间要么就是六点回来睡到九点或者就是冻的脑袋疼，中间穿插几次聚餐（师兄分享会），所以呢，几乎晚上也没有时间来搞一搞这个东西，所以就同时更一下未了的心愿吧。<br>这几天在哈汽建模，其实也学到了挺多，一个是原来微晕公交车，到后来在上面玩手机一个小时没问题，我真是太容易融入环境了。。。再者就是做什么事都要细心哪，要知道身边人大家都很优秀，不是说超越谁，就是追赶也不得放松丝毫。这几天建模，确实刷新了我的一些认识，我觉得某些地方无法解决的问题，在我心里就觉得是图纸问题，因为五张A0，十几张A4难免会有失误，但是探讨之后，几乎所有的问题都迎刃而解，所以不懂的地方就多去问问别人啊！你以为人企业是吃啥饭的，图纸怎么可能有那么多问题呢，先从自己身上找问题吧。<br>所以说认真，渐渐的发现其实身边的所有人都有一个基本的素质，那就是细心，越是大的东西，你越要一点一滴自信斟酌，不要想当然，一定要先说服自己，但是还是那句话，不明白的多去问问别人，实在是太缺少团队协作能力了，这次和小组合作，确实也提升了不少这方面知识。认真<br>还想说点关于师兄分享的内容，一个说的是平时要多积累东西，增加见识面，然后工作中遇到类似的东西，可以不像别人那样惊叹，更加从容镇定，告诉老板这东西我知道。。。第二点就是业务，要知道怎么喝酒，喝酒的流程，怎么陪领导喝酒，也会得到领导的另眼相看。<br>另一个学长给我的感觉就是充分分析自身的情况，选择自己想要的工作，有自己的想法，管培生和公务员这方面都不好干，公务员可能某天突然就成了别人的炮灰了。目前形势比较好的就是研究所和一些大企业。</p><p>实际上，我是比较想转行做程序员的，为什么呢，我也想过这个问题，给自己的答案是，比较喜欢能干出实际东西的行业，比如写段程序直接就运行得到你要的结果了，而且实际的开销比较小，效益高，工资高，嘻嘻。当然梦想没实现就是梦想，如果一年后我真的签了程序员工组，一定会在这条路上越走越远，越快。<br>如果呢，梦想不能实现，那也没啥气馁的，至少还是很有盼头的，那样的话，我可能就去了南方的某个企业去做工业工程或者去洛阳613所当了一名为研究所贡献一生的普通人。<br>上面这段话就是我的找工作心里预期的排序。</p><p>好了，加油吧，认真点！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo添加“不蒜子”统计网站访问量</title>
    <link href="/2019/10/02/2processing/"/>
    <url>/2019/10/02/2processing/</url>
    
    <content type="html"><![CDATA[<p>添加网站访问量统计有多种方式，比如不蒜子、百度统计、谷歌统计、cnzz统计等<br>因为本主题为nexmoe，查看了配置文件中默认没有支持不蒜子统计，所以本文就对于添加不蒜子统计进行配置过程的记录</p><a id="more"></a><ol><li><p>安装不蒜子脚本</p><pre><code> &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; {% if theme.footer.counter %}            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>            <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>            <span class="post-meta-divider">|</span>            <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>        {% endif %}</code></pre></li></ol><p>将上述脚本复制到“\themes\nexmoe\layout_partial文件夹中的footers.ejs或者是（after-footers.ejs）文件(有的是swig文件）的尾部。<br>2. 修改themes主题下的_config.yml文件</p><pre><code>    # visitors count    counter: true</code></pre><ol start="3"><li><p>设置显示位置<br>（1）pv的方式，单个用户连续点击n篇文章，记录n次访问量：</p><pre><code> &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;     本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt;</code></pre></li></ol><p>（2）uv的方式，单个用户连续点击n篇文章，只记录1次访客数：</p><pre><code>    &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;      本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次    &lt;/span&gt;</code></pre><p>（3）将上述两个代码复制，放到headers中的最外层的div标签里面：</p><pre><code>    &lt;/div&gt;    &lt;div align=&quot;center&quot;&gt;        &lt;span id=&quot;busuanzi_container_site_pv&quot; align=&quot;center&quot;&gt;        本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次        &lt;/span&gt;        &lt;br&gt;        &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;        本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次        &lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- .nexmoe-drawer --&gt;</code></pre><p>要想让统计居中，添加一个div标签，设置为居中，将上述代码复制在其中。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome to zzzspider&#39;s blog</title>
    <link href="/2019/09/29/firstpage.html/"/>
    <url>/2019/09/29/firstpage.html/</url>
    
    <content type="html"><![CDATA[<p>无意之中看见通过github pages来搭建一个小网站的教程，竟然不用购买服务器，还有现成的网页模板可以使用，着实吃了一鲸<br>于是，今天就在欲望的驱动下，使用轮子，造一个网站吧。。。。。</p><a id="more"></a><p>（这里有一行注释。。。竟然占了一整行）<!--[![注释](https://i.loli.net/2019/09/29/RatxhS3zXopqi6H.gif)](https://www.baidu.com/ "导航")--><br>喵一眼时间，21：49：10<br>完了，一会得走了，先简短的对这个过程做个总结啪<del>~</del></p><ol><li><p>github账号有一个，然后创建一个仓库（用来当服务器鸭），设置域名为yourname.github.io</p></li><li><p>需要安装的如下：<br> –1. git  git是代码托管软件，github是代码托管平台，据说是同一个东西，只是呈现方式不同而已，就是用它的bush来实现代码传到github<br> –2. nodejs 是一个js的运行环境，就是前端的javascript，，因为hexo是基于nodejs编写，所以需要安装。。<br> –3. hexo  静态博客框架，你要是不想自己写一大堆html、css、js的话，就用他吧</p></li><li><p>具体操作过程包括但不限于：添加ssh到github上，把hexo部署到github上。。。<br> ssh是一种传输协议，用来实现文件传输，hexo部署到github上之后，就可以访问yourname.github.io，就可以看到你的hexo页面效果了。当然你也可以hexo server通过本地页面来观看效果。</p></li><li><p>设置个人域名。简单来说yourname.github.io相当于你的顶级域名，然后可以添加子域名比如zzzspider.top来访问，但是这个域名是要花钱滴~（阿里云新用户1元/年^_^，需要实名，不然不通，搞了一下午，实名之后可以了），然后呢添加域名解析（就是将zzzspider.top绑定到yourname.github.io的同一个ip上），ip查看就用ping就行；<br>然后在你的yourname.github.io上设置添加子域名。<br>这样两头都通了，那就通了，就可以使用zzzspider.io来查看你的网站辣。</p></li></ol><p>5.hexo的使用，先用hexo初始化一个文件夹，hexo init name,name就是文件夹名，然后在文件夹下npm install，之后就会创建一系列文件，就是你的hexo配置文件。之后需要什么操作就在里面改就行了，至于写文章hexo new title，创建一个文章，然后格式是md。</p><ol start="6"><li><p>部署呢就是：<br>hexo clean<br>hexo generate<br>hexo deploy<br>这样，你本地hexo啥样，部署到服务器就是啥样，所以写完可以现在本地看一下，然后在部署到服务器上，就更新了网站。</p></li><li><p>说了这么多，终于把步骤贴出来了，全过程参照但不局限于以下几个帖子：<br><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">铁子1</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzA4NDk3Nw==&mid=2457738181&idx=1&sn=0a204aa85ef7db1df0ff93c178121315&chksm=ff44b39bc8333a8d14adcec4df4c2bd305d67e0711526ade76f54d37a573e8d37efc0c4b64f6&mpshare=1&srcid=&sharer_sharetime=1569505999394&sharer_shareid=89617866ac20519a0a190ba9770a2185&from=timeline&scene=2&subscene=2&clicktime=1569766955&enterid=1569766955&ascene=2&devicetype=android-28&version=27000736&nettype=3gnet&abtest_cookie=BQABAAgACgALABIAEwAFAJ2GHgAjlx4AVpkeAMSZHgD2mR4AAAA%3D&lang=zh_CN&pass_ticket=sqlr5jMu3XGBDdmi30i7LUgwmLltDu85mROxvc9n8BxUB52MvrKMCWhUXlgbcz4m&wx_header=1" target="_blank" rel="noopener">铁子2</a><br>虽然只是一篇照葫芦画葫芦的文章，但是领悟力比较之前提高了一丢丢吧<br>good night    ^_^</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>welcome</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
