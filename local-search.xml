<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>btc趋势分析1</title>
    <link href="/2020/05/06/btc%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%901/"/>
    <url>/2020/05/06/btc%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<p>常言道，赔钱不可怕，一直赔钱才可怕。</p><a id="more"></a><p>经历过之前额赔钱经历之后，我深深感到了市场额恶意，虽说只有两千块钱左右，<br>但是作为一个学生的我，真的是资金周转了好久才周转了过来，以后记得，这种高风险的事情，一定不要借钱去玩<br>所以，赔的不服气，我只好又往里面充了几百，加上拉上应旭<br>本来盈利了30%左右，但是怕自己操作不好再亏了，所以一直没动，然后。。<br>美股熔断，btc也遭受悬崖式下跌，那一点利润迅速回吐，目前也是赔钱的<br>但是之前学习的一大堆理论知识，你说没用么，不是的，肯定是有用的，为什么会赔钱呢<br>心理！<br>市场是由人来推动的，他展现给你什么样，他就是什么样，可是为什么每次赢得只有那5%。我觉得有以下几点：<br>1.看不清市场，每个人都有一套自己的交易法则，看着k线来判断是增是长，这个无可厚非，没有绝对的对与错，只有最终的结果，你的胜率与失败率额比例，胜率高，最终结果就是好的。当然，这一切都要建立在你从头到尾都始终坚信并且坚决执行你自己的策略上。<br>2.看不清自己，上面说了，人不同，可能交易方式不同。但是为什么有的人能赢？<br>追涨杀跌，这种人没有自己的一套交易法则，只是道听途说，或者只是单纯的看k线，觉得涨了就买，跌了就卖。殊不知，在你看到这种涨跌的大趋势的时候，趋势已经处于结束的尾声了，就算是在趋势发生的中间时间发现，也是可以赚钱的，那前面赚的钱是哪来的？不就是这些最后入场，赔个精光的人的钱。<br>3.没有自制力，之前学的那些理论，（趋势交易分析）还有各种什么论，这种论，我只有觉得  趋势交易是最适合我的，我比价喜欢看图形，也比较喜欢画图形，而趋势交易就是看图形，画图形，然后分析后续。<br>作为满打满算也有一年的市场参与者，从最初买入卖出，到参与期货交易，到最后赔的血本无归。期间也经历过晚上紧张的睡不着，第二天起来直接翻倍，要么第二天醒来直接爆仓。也经历过资金从四百块涨到一千块，然后回吐，然后继续充钱，最后归零。<br>我充分体验到了人性的贪婪与人性的恐惧，对于自己，我更深有体会。<br>贪婪，使我赢了一茬之后，不愿意提出本钱，甚至变本加厉的充！最终结果就是从百分百利润，到百分百了亏损。<br>有句话说的真好，只要你的手中没有得到这笔钱，那你就没有盈利，你收益率多少不能证明什么，你手机最终得到了多少钱，才是真的。<br>我是深有体会，从把本金和收益提出来这件事上，就是一个艰难的过程，你要克服自己的贪婪，欲望，和它还会涨的幻想！<br>这，真的是非常的难！<br>恐惧，使我对这个市场的评判越来越不客观，因为别人的分析，与我的分析有段时间一致，但是市场明显与我的分析不一致，但是有人一起死，总比自己一个人要强，所以我选择相信那个人，却没有相信市场，因为怕输了，就只有自己输了，没有坚持自己的方法，甚至连分析都懒得分析。<br>趋势。是我分析的依据，我明明知道它多么的有效，因为我也曾多次用它实现百分之几百的利润，所以以后的日子，我想就按照它来交易了。最后一句话，评判你的交易方法有没有用的不是看你会不会输，而是盈利与失误比，只要大于百分之五十，你就能获利，但是一定要记得，坚定的按照自己的方式去执行！</p><p>因为我准备使用自动化的方式，通过计算与理论结合，将趋势与算法结合，一步步改进的方式来实现盈利，这也算是我一步步学习的见证，还有学习的根据地。</p>]]></content>
    
    
    
    <tags>
      
      <tag>btc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十-詞-鸽-负</title>
    <link href="/2020/04/30/%E5%8D%81-%E8%A9%9E-%E9%B8%BD-%E8%B4%9F/"/>
    <url>/2020/04/30/%E5%8D%81-%E8%A9%9E-%E9%B8%BD-%E8%B4%9F/</url>
    
    <content type="html"><![CDATA[<p>如果有来生，要做一棵树<br>                    –三毛</p><a id="more"></a><p>如果有来生，要做一棵树，<br>站成永恒。<br>没有悲欢的姿势，<br>一半在尘土里安详，<br>一半在风里飞扬；<br>一半洒落荫凉，<br>一半沐浴阳光。<br>非常沉默、非常骄傲。<br>从不依靠、从不寻找。</p><p>如果有来生，要化成一阵风，<br>一瞬间也能成为永恒。<br>没有善感的情怀，没有多情的眼睛。<br>一半在雨里洒脱，<br>一半在春光里旅行；<br>寂寞了，孤自去远行，<br>把淡淡的思念统统带走，<br>从不思念、从不爱恋；</p><p>如果有来生，要做一只鸟，<br>飞越永恒，没有迷途的苦恼。<br>东方有火红的希望，<br>南方有温暖的巢床，<br>向西逐退残阳，向北唤醒芬芳。<br>如果有来生，<br>希望每次相遇，<br>都能化为永恒。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作研究与人因工程-1</title>
    <link href="/2020/04/22/%E5%B7%A5%E4%BD%9C%E7%A0%94%E7%A9%B6%E4%B8%8E%E4%BA%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B-1/"/>
    <url>/2020/04/22/%E5%B7%A5%E4%BD%9C%E7%A0%94%E7%A9%B6%E4%B8%8E%E4%BA%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>工作研究与人因工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这些天</title>
    <link href="/2020/04/16/%E8%BF%99%E4%BA%9B%E5%A4%A9/"/>
    <url>/2020/04/16/%E8%BF%99%E4%BA%9B%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>好几天没有写博客了呢，今天就总结一下这些天的事情吧。</p><a id="more"></a><p>这几天关于数据分析的一直没有更新，只是没有发而已，而我的东西都放在了jupyter上了，不想再发一遍，所以</p><p>今天去找了张乾，他找的工作挺好的，工资也很高，但是是工程管理、质量管理，好多人都学了这个。。。</p><p>然后聊起了他现在谈的对象，他说他想分了，但是家长都知道了，亲戚也都知道了，家长也都认识。。。</p><p>我笑死了，哈哈哈</p><p>不过在他心里就是和分手差不多了。</p><p>然后，又聊起了小马，说了一通后，我说分了，哈哈哈有点尴尬</p><p>然后又说了两句于，没想到啊，上次快递那取快递，她居然认得我，还跟乾问下是不是我??</p><p>说很喜欢捏鼻子？我喜欢捏鼻子么？确定是我，还记得我欠她几顿饭，哈哈，</p><p>乾哥说，年前在饭店见到我们，说我胖了，还非得在窗外看看我胖了？？？</p><p>wtf，</p><p>吓到我了，呵呵呵，年前属实胖，不过快递那次碰面，我应该瘦了很多吧。。。</p><p>嘎~</p><p>说实话，挺后悔当初的选择，那时啥也不知道，胆小怯懦，，，，，，</p><p>原来考研二战了啊，虽然成绩不理想，还有准备公务员考试的话，就加油吧。</p><p>也不知道经过了这一年学到了多少，明白了多少，成熟了多少，反正我啊，感觉自己成熟了很多了</p><p>嗯。。。<br><img src="/img/zhexietian.jpg" srcset="/img/loading.gif" alt=""></p><p>加油！</p><p>乾哥说起你，我漫不经心，或许是装的，或许是真的，</p><p>可是这些问题又有什么意义呢，大家在不同的空间，不同的时间，不同的经历，不同的人生</p><p>我还在越来越瘦呢，又帅起来了</p><p>我为什么要说又呢，自信！</p><p>好了，听说时间安排的很紧，看不见的话，我就写给自己听了，</p><p>曾温柔时光，愿时间不会亏待你~</p><p>加油辣！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说几句</title>
    <link href="/2020/04/14/%E8%AF%B4%E5%87%A0%E5%8F%A5/"/>
    <url>/2020/04/14/%E8%AF%B4%E5%87%A0%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>你说呢</p><a id="more"></a><p>我们都在路上或多或少的迷茫，何为恐惧，又名无知。</p>]]></content>
    
    
    
    <tags>
      
      <tag>-life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔~</title>
    <link href="/2020/04/09/%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/04/09/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>原来人要高兴这么简单，哈哈哈哈<br>我还是从前那个少年~</p><a id="more"></a>    <p>今天去大庆取快递，<br>报了号码，后面一个女生在那说号码<br>刹那间，这个声音，有点熟悉<br>我往回头看了一下，带着口罩，和眼镜，和黑色的一身衣服，<br>不像，但是又有点像，，这眼神？<br>我还是挺了挺腰背，<br>终于在我取完快递那一刻，<br>叫道了她的名字，yu xu ya<br>妈耶，说实话，当时手抖了，哈哈哈<br>（不过她好像没我想象中那么高了，嘎）<br>然后我双手拿着快递，从她身边拿走了，<br>没说话，我没敢搭讪<br>然后上了车</p><p>下着雨<br>我开着车<br>她打着伞<br>我故意把车掉头时候慢了点<br>她在我后面走了过来<br>终于还是没有勇气摇下车窗<br>说出送她一程<br>只能一路狂飙回去了</p><p>真<br>没胆啊<br>狗子张<br>哈哈哈哈</p><p>不过啊，<br>女神这种生物，<br>不就是要远远的看着么，<br>甚至是信仰问题了，<br>哈哈</p><p>你最近咋样呢，<br>是好是坏，<br>与我无关了，<br>我也不会去打听了，<br>信仰这东西，<br>你去信，<br>就行了，<br>千万不要去试图打搅它哦</p><p>也许以后的某天，<br>也是同样的场景，<br>我叫了一下你，<br>礼貌的说了两句话，<br>大家都笑嘻嘻，<br>然后告别，<br>我可能又会乐半天，</p><p>哈哈哈哈<br>你别笑，<br>我，<br>好久没有这种感觉了，<br>女神啊，<br>祝你幸福！</p><p>今天，<br>心跳了一下，<br>已经很开心了。^-^</p><p>好久不见~</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>钓鱼趣事-嘎</title>
    <link href="/2020/04/08/%E9%92%93%E9%B1%BC%E8%B6%A3%E4%BA%8B-%E5%98%8E/"/>
    <url>/2020/04/08/%E9%92%93%E9%B1%BC%E8%B6%A3%E4%BA%8B-%E5%98%8E/</url>
    
    <content type="html"><![CDATA[<p>这几天学了一手</p><a id="more"></a><p>4.8 晴 早上七点起床钓鱼 钓了两个钟头 专心致志 一心一意 终于没钓到 走了<br>哈哈哈~<br>然后下午又约了一波<br>这篇博客，就写两件事吧：</p><h1 id="1-钓鱼大法！"><a href="#1-钓鱼大法！" class="headerlink" title="1.钓鱼大法！"></a>1.钓鱼大法！</h1><p>首先是活钓饵，如果是用饵料的话，需要活成教软的状态，然后一直揉，就可以拉出丝了，这样不容易掉<br>然后是鱼竿，差不多鱼线比鱼竿稍微长一点，不要长太多，不然没法甩杆，不要短太多，不然甩的太近；浮漂的话要按照水深来定，大概让饵料基本沉底的时候，留三格左右的浮漂就可以了。<br>接下来是甩钩，拉住铅坠，用鱼竿的弹性，将饵料弹出去，<br>然后就是重头戏了，一直盯着，当然，眼睛会疼。。。。。。。<br>盯。。。。。。。。。。。。。。。。。。。<br>突然，饵料稍微动了一下，别急，这是鱼儿在饵料周围游，<br>然后饵料突然上下浮动就是鱼儿在吃饵料了，等浮漂下去时候，一定要突然提鱼竿，一定要突然，速度越快越好。<br>然后，一瞬间就知道有没有上鱼了，如果没有就是没有，如果有就可以了。。<br>最后，如果鱼儿肚子很胀，就是有鱼籽了，放了吧。。。</p><h1 id="2-写写大家"><a href="#2-写写大家" class="headerlink" title="2.写写大家"></a>2.写写大家</h1><p>我这人，朋友很多，好朋友也很多，很高兴有事叫一下大家都会帮，当然大家有问题都会互相帮助的。<br>自从回归单身超级用户之后，对朋友真的都好了很多呢，能付钱的，我都会付钱，多约朋友吃饭啥的，能掏钱都掏了<br>丝毫没有觉得可惜，对于这些死党们，真想对他们好啊，大家都一起进步吧！！！！<br>legends never die —-刚好现在听到了这首歌<br>这回见到郭满是真的意外，小妮子这回打扮的非常可以，哈哈哈<br>除了胖和黑外，其它方面也算上等，古灵精怪，也长的很好看，这回打扮的白了，确实好看了很多，哈哈哈下手晚了。<br>可惜了<br>不过，这回看见她真的是不知道咋回事嫩高兴，哈哈哈哈，当着恁多大人面大声喊她，不过觉得也没啥，她和陈真的是我们一起幼稚了，虽然没有一起成熟，我觉得是跟自己家人一样的感觉吧。<br>总之，今天过的很高兴，钓到了于，见到了朋友们，早起了，静心了，也学了一会习</p><p>哎，晚上坐在床上写写博客，听着歌，好tm的舒服啊。嘎</p><p>附上今天偶然看到的一句诗：杜鹃花开春已阑,归向陵阳钓鱼晚。</p><p>2020.4.8—未来可期，加油吧，张弟弟！</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代质量工程课程-2</title>
    <link href="/2020/04/03/%E7%8E%B0%E4%BB%A3%E8%B4%A8%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B-2/"/>
    <url>/2020/04/03/%E7%8E%B0%E4%BB%A3%E8%B4%A8%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B-2/</url>
    
    <content type="html"><![CDATA[<p>第二课</p><a id="more"></a><h1 id="三、全过程质量管理"><a href="#三、全过程质量管理" class="headerlink" title="三、全过程质量管理"></a>三、全过程质量管理</h1><p><img src="/img/quanmianzhiliang.png" srcset="/img/loading.gif" alt=""><br>此处略去三节课</p><h2 id="4-全面质量管理的核心观点"><a href="#4-全面质量管理的核心观点" class="headerlink" title="4.全面质量管理的核心观点"></a>4.全面质量管理的核心观点</h2><h3 id="4-1用户至上"><a href="#4-1用户至上" class="headerlink" title="4.1用户至上"></a>4.1用户至上</h3><h3 id="4-2一切凭数据说话"><a href="#4-2一切凭数据说话" class="headerlink" title="4.2一切凭数据说话"></a>4.2一切凭数据说话</h3><h3 id="4-3以预防为主"><a href="#4-3以预防为主" class="headerlink" title="4.3以预防为主"></a>4.3以预防为主</h3><p>好的产品质量是设计和制造出来的，而不是检验出来的。</p><h3 id="4-4以质量求效益"><a href="#4-4以质量求效益" class="headerlink" title="4.4以质量求效益"></a>4.4以质量求效益</h3><h3 id="4-5以零缺陷为目标"><a href="#4-5以零缺陷为目标" class="headerlink" title="4.5以零缺陷为目标"></a>4.5以零缺陷为目标</h3>]]></content>
    
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代质量工程课程-1</title>
    <link href="/2020/04/02/%E7%8E%B0%E4%BB%A3%E8%B4%A8%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B-1/"/>
    <url>/2020/04/02/%E7%8E%B0%E4%BB%A3%E8%B4%A8%E9%87%8F%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<h1 id="为了限制自己上课，就通过记笔记来吧，顺便练习一下记笔记。"><a href="#为了限制自己上课，就通过记笔记来吧，顺便练习一下记笔记。" class="headerlink" title="为了限制自己上课，就通过记笔记来吧，顺便练习一下记笔记。"></a>为了限制自己上课，就通过记笔记来吧，顺便练习一下记笔记。</h1><a id="more"></a><h1 id="一、质量工程概述"><a href="#一、质量工程概述" class="headerlink" title="一、质量工程概述"></a>一、质量工程概述</h1><h2 id="1-基本概念和定义"><a href="#1-基本概念和定义" class="headerlink" title="1.基本概念和定义"></a>1.基本概念和定义</h2><h3 id="1-1质量"><a href="#1-1质量" class="headerlink" title="1.1质量"></a>1.1质量</h3><p>质量是指 反映实体满足明确和隐含需要的能力的特性总和。<br>实体是 可单独描述和研究的事物<br>需要分为明确需要和隐含需要，明确需要是指双方明确规定的内容；隐含是指人们公认的，不言而喻的需要<br>特性 指实体所持有的性质，反映了实体满足需求的能力。<br>日本田口玄一从经济学角度给质量下定义<br>美国朱兰从用户角度给质量下定义</p><h3 id="1-2产品质量"><a href="#1-2产品质量" class="headerlink" title="1.2产品质量"></a>1.2产品质量</h3><p>产品质量是指产品能满足人们的需要而应具备的特性，<br>就机械工业的硬件产品而言，大致可以归纳为一下六个方面的特性：<br>1.性能 2.可信性 3.安全性 4.适应性 5.经济型 6.时间性（供货、产品随时间变化、产品寿命）<br>就服务类别产品而言：<br>1.功能性 2.经济性 3.安全性 4.时间性 5.舒适性 6.文明性<br>就软件类别产品：<br>1.性能 2.安全性 3.可靠性 4.保密性 5.专用性 6.经济性</p><h3 id="1-3过程质量"><a href="#1-3过程质量" class="headerlink" title="1.3过程质量"></a>1.3过程质量</h3><p>过程：将输入转化为输出额一组彼此相关的资源和活动。过程一定要增值<br>过程质量：可理解为过程满足规定需要或潜在需要的特性的总和。<br>过程质量包括：<br>1.规划过程质量 2.设计过程质量(是产品的固有质量问题，没法解决，质量问题大多70%问题出现在此环节) 3.制造过程质量 4.使用过程质量(产品使用过程中提现的质量) 5.报废处理过程质量(是设计质量的体现之一) 6.服务过程质量(只服务要求的满足程度)</p><h3 id="1-4工作质量"><a href="#1-4工作质量" class="headerlink" title="1.4工作质量"></a>1.4工作质量</h3><p>一般指企业生产经营中各项工作对产品和服务质量的保证程度。<br>工作质量不像产品和服务质量那样直观的表现在人的面前，而是体现在生产、技术、经营活动中，通过工作效率和成果，最终体现在3产品质量和经济效益上。</p><h3 id="1-5狭义质量和广义质量"><a href="#1-5狭义质量和广义质量" class="headerlink" title="1.5狭义质量和广义质量"></a>1.5狭义质量和广义质量</h3><p>狭义质量 仅从用户角度来看质量<br>广义质量 不仅从客户角度看质量，同时还从制造者和社会角度理解 质量</p><h3 id="1-6寿命周期和循环质量"><a href="#1-6寿命周期和循环质量" class="headerlink" title="1.6寿命周期和循环质量"></a>1.6寿命周期和循环质量</h3><p>从产品产生到报废的整个过程称为产品的寿命周期循环，将产品寿命周期的各过程的质量问题，称为质量环<br>质量螺旋侧重企业内部的质量循环和与外部的关系<br>质量环则从寿命周期的角度论述质量活动的不间断性<br><img src="/img/zhiliang.png" srcset="/img/loading.gif" alt=""><br><img src="/img/zhilianghuan.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-7零缺陷、零废品、零故障和零污染是质量管理的追求"><a href="#1-7零缺陷、零废品、零故障和零污染是质量管理的追求" class="headerlink" title="1.7零缺陷、零废品、零故障和零污染是质量管理的追求"></a>1.7零缺陷、零废品、零故障和零污染是质量管理的追求</h3><h3 id="1-8质量工程"><a href="#1-8质量工程" class="headerlink" title="1.8质量工程"></a>1.8质量工程</h3><p>定义：为保证满足客户和社会对产品和服务质量的需求，组织与社会所采取的一切相关活动的总和。<br>分为三部分：质量管理、社会环境、质量监督<br><img src="/img/zhilianggongcheng.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-提高产品质量的意义"><a href="#2-提高产品质量的意义" class="headerlink" title="2.提高产品质量的意义"></a>2.提高产品质量的意义</h2><h3 id="2-1质量与人生活息息相关"><a href="#2-1质量与人生活息息相关" class="headerlink" title="2.1质量与人生活息息相关"></a>2.1质量与人生活息息相关</h3><h3 id="2-2质量是企业生存发展的保障"><a href="#2-2质量是企业生存发展的保障" class="headerlink" title="2.2质量是企业生存发展的保障"></a>2.2质量是企业生存发展的保障</h3><p>我刚刚给师姐说话，这一段就PASS掉</p><h3 id="2-3质量检验、统计质量控制和全面质量管理的比较"><a href="#2-3质量检验、统计质量控制和全面质量管理的比较" class="headerlink" title="2.3质量检验、统计质量控制和全面质量管理的比较"></a>2.3质量检验、统计质量控制和全面质量管理的比较</h3><p>如图：<br><img src="/img/zhiliangjianyan.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-7</title>
    <link href="/2020/04/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-7/"/>
    <url>/2020/04/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-7/</url>
    
    <content type="html"><![CDATA[<h1 id="七、数据分析第七课-数据排序"><a href="#七、数据分析第七课-数据排序" class="headerlink" title="七、数据分析第七课-数据排序"></a>七、数据分析第七课-数据排序</h1><a id="more"></a>    <h2 id="1-数据排序"><a href="#1-数据排序" class="headerlink" title="1.数据排序"></a>1.数据排序</h2><p>有两种排序方法，就是series和dataframe<br>首先</p><pre><code>    import pandas as pd    path = &#39;./daily_price_btc_cny.csv&#39;    df = pd.read_csv(path)</code></pre><h3 id="1-1series排序"><a href="#1-1series排序" class="headerlink" title="1.1series排序"></a>1.1series排序</h3><pre><code>    df[&#39;open&#39;].sort_values(ascending=False)    #默认升序排列    #ascending=False  为降序排列    结果：    1462    30878.76    1461    29902.03    1447    29540.00    1459    29496.00    1463    29410.50              ...       6         739.20    23        735.95    24        733.00    7         725.79    8         715.86    Name: open, Length: 1480, dtype: float64</code></pre><h3 id="1-2dataframe排序"><a href="#1-2dataframe排序" class="headerlink" title="1.2dataframe排序"></a>1.2dataframe排序</h3><p>按照单行排序</p><pre><code>    #按照单行排序    df.sort_values(by=&#39;close&#39;)    结果：        date    open    high    low    close    volume    7    2013/9/8    725.79    732.00    715.85    715.86    698.4290    6    2013/9/7    739.20    740.40    696.90    725.00    1033.8905    23    2013/9/24    735.95    741.00    729.30    729.30    684.1842    32    2013/10/3    778.00    778.00    679.11    735.00    3876.1255    22    2013/9/23    745.61    746.00    730.43    736.00    450.8465    ...    ...    ...    ...    ...    ...    ...    1462    2017/9/2    30878.76    32350.00    28580.00    29400.08    15812.8839    1458    2017/8/29    28610.00    30000.00    28510.93    29496.00    13410.0600    1446    2017/8/17    29017.00    30299.99    28680.10    29510.03    17491.4300    1460    2017/8/31    29284.03    30099.99    29100.00    29949.00    8766.4873    1461    2017/9/1    29902.03    30988.00    29651.11    30878.76    12207.8512</code></pre><p>按照多行排序</p><pre><code>    #按照多行排序，默认两个都升序    df.sort_values(by=[&#39;date&#39;,&#39;open&#39;])    #先按照date进行排序，然后如果date中有一样的，在按照open排序    #按照多行排序，都是降序    df.sort_values(by=[&#39;date&#39;,&#39;open&#39;],ascending = False)    #按照多行排序，都是降序    df.sort_values(by=[&#39;date&#39;,&#39;open&#39;],ascending = False)</code></pre><h2 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="2.字符串处理"></a>2.字符串处理</h2><h3 id="2-1str属性"><a href="#2-1str属性" class="headerlink" title="2.1str属性"></a>2.1str属性</h3><pre><code>    df.dtypes    #查看各列的类型，注意str属性只能在字符串列使用，就是object    #在数字列使用str属性的话会报错    #只能用series处理字符串，df没有这个属性    df[&#39;date&#39;].str    df[&#39;date&#39;].str.replace(&#39;/&#39;,&#39;-&#39;)    df[&#39;open&#39;].str.len()    结果报错</code></pre><h3 id="2-2使用str的startwith、contains等得到bool的series可以做条件查询"><a href="#2-2使用str的startwith、contains等得到bool的series可以做条件查询" class="headerlink" title="2.2使用str的startwith、contains等得到bool的series可以做条件查询"></a>2.2使用str的startwith、contains等得到bool的series可以做条件查询</h3><pre><code>    condition = df[&#39;date&#39;].str.startswith(&#39;2017/9&#39;)    condition    结果：结果是bool值    0       False    1       False    2       False    3       False    4       False            ...      1475     True    1476     True    1477     True    1478     True    1479     True    df[condition].head    结果：    date      open      high       low     close      volume    1461   2017/9/1  29902.03  30988.00  29651.11  30878.76  12207.8512    1462   2017/9/2  30878.76  32350.00  28580.00  29400.08  15812.8839    1463   2017/9/3  29410.50  30398.00  27577.00  28310.69   9638.3445    1464   2017/9/4  28260.09  29000.00  25902.00  26348.17  18774.3634    1465   2017/9/5  26348.17  27376.00  22592.31  26060.00  31772.2396    1466   2017/9/6  26010.90  28810.00  26000.00  28656.90  17436.5092    1467   2017/9/7  28745.00  29348.06  28100.01  29027.68  11196.6343    1468   2017/9/8  29027.68  29200.00  23131.40  25114.90  24609.8043    1469   2017/9/9  25113.00  26320.00  23300.00  24428.80  27006.0589</code></pre><h3 id="2-3多次使用str属性"><a href="#2-3多次使用str属性" class="headerlink" title="2.3多次使用str属性"></a>2.3多次使用str属性</h3><p>例，将日期中的年月提取出来</p><pre><code>    df[&#39;date&#39;].str.replace(&#39;/&#39;,&#39;&#39;).str.slice(0,6)    #先用str的replace替换，然后用str的slice切片取出第0个到第6个    结果：    0       201391    1       201392    2       201393    3       201394    4       201395             ...      1475    201791    1476    201791    1477    201791    1478    201791</code></pre><h2 id="3-index操作"><a href="#3-index操作" class="headerlink" title="3.index操作"></a>3.index操作</h2><pre><code>    import numpy as np    df =pd.DataFrame(        np.arange(12).reshape(3,4),        columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]    )    df    产生这样一个3行4列的数据表        A    B    C    D    0    0    1    2    3    1    4    5    6    7    2    8    9    10    11</code></pre><h3 id="3-1删除某一列"><a href="#3-1删除某一列" class="headerlink" title="3.1删除某一列"></a>3.1删除某一列</h3><pre><code>    df.drop(&#39;A&#39;,axis=1)    #axis=1表示列,或者axis=column    结果：        B    C    D    0    1    2    3    1    5    6    7    2    9    10    11</code></pre><h3 id="3-2删除某一行"><a href="#3-2删除某一行" class="headerlink" title="3.2删除某一行"></a>3.2删除某一行</h3><pre><code>    df.drop(&#39;A&#39;,axis=1)    #axis=1表示列,或者axis=column    结果：    A    B    C    D0    0    1    2    32    8    9    10    11</code></pre><h3 id="3-3按axis-0-index执行mean聚合操作–遍历行，找到列的均值"><a href="#3-3按axis-0-index执行mean聚合操作–遍历行，找到列的均值" class="headerlink" title="3.3按axis=0/index执行mean聚合操作–遍历行，找到列的均值"></a>3.3按axis=0/index执行mean聚合操作–遍历行，找到列的均值</h3><pre><code>    按axis=0/index执行mean聚合操作--遍历行，找到列的均值    结果：    A    4.0    B    5.0    C    6.0    D    7.0    dtype: float64</code></pre><h3 id="3-4按axis-1-column执行mean聚合操作–遍历列，找到行的均值"><a href="#3-4按axis-1-column执行mean聚合操作–遍历列，找到行的均值" class="headerlink" title="3.4按axis=1/column执行mean聚合操作–遍历列，找到行的均值"></a>3.4按axis=1/column执行mean聚合操作–遍历列，找到行的均值</h3><pre><code>    df.mean(axis=1)    结果：    0    1.5    1    5.5    2    9.5    dtype: float64</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-6</title>
    <link href="/2020/04/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-6/"/>
    <url>/2020/04/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-6/</url>
    
    <content type="html"><![CDATA[<h1 id="六、数据分析第六课-数据清洗"><a href="#六、数据分析第六课-数据清洗" class="headerlink" title="六、数据分析第六课-数据清洗"></a>六、数据分析第六课-数据清洗</h1><a id="more"></a>    <h2 id="1-读取数据"><a href="#1-读取数据" class="headerlink" title="1.读取数据"></a>1.读取数据</h2><p>数据如图所示的，前两行有空值，左边有空值，中间也有空值的数据。<br><img src="/img/shuju.png" srcset="/img/loading.gif" alt=""><br>首先读取数据要先将前两行给过滤掉（skiprows=2）：</p><pre><code>    df = pd.read_excel(r&#39;./数据清洗.xlsx&#39;,skiprows=2)    df    结果：        Unnamed: 0    姓名    科目    分数    0    NaN    小明    语文    85.0    1    NaN    NaN    数学    85.0    2    NaN    NaN    英语    85.0    3    NaN    NaN    NaN    NaN    4    NaN    小王    语文    86.0    5    NaN    NaN    数学    NaN    6    NaN    NaN    英语    86.0    7    NaN    NaN    NaN    NaN    8    NaN    小刘    语文    87.0    9    NaN    NaN    数学    87.0    10    NaN    NaN    英语    87.0</code></pre><h2 id="2-检测空值"><a href="#2-检测空值" class="headerlink" title="2.检测空值"></a>2.检测空值</h2><pre><code>    #监测表中所有数据是否是空值，true表示空值，false非空值    df.ismull()    结果：        Unnamed: 0    姓名    科目    分数    0    True    False    False    False    1    True    True    False    False    2    True    True    False    False    3    True    True    True    True    4    True    False    False    False    5    True    True    False    True    6    True    True    False    False    7    True    True    True    True    8    True    False    False    False    9    True    True    False    False    10    True    True    False    False    #与之相反，notnull的结果与isnull相反，看需要来选择    df.notnull()</code></pre><p>检测单个列</p><pre><code>    df[&#39;姓名&#39;].isnull()    结果：    0     False    1      True    2      True    3      True    4     False    5      True    6      True    7      True    8     False    9      True    10     True</code></pre><h2 id="3-筛选分数没有空值的所有行："><a href="#3-筛选分数没有空值的所有行：" class="headerlink" title="3.筛选分数没有空值的所有行："></a>3.筛选分数没有空值的所有行：</h2><pre><code>    df.loc[df[&#39;分数&#39;].notnull(),:]    结果：    Unnamed: 0    姓名    科目    分数        0    NaN    小明    语文    85.0        1    NaN    NaN    数学    85.0        2    NaN    NaN    英语    85.0        4    NaN    小王    语文    86.0        6    NaN    NaN    英语    86.0        8    NaN    小刘    语文    87.0        9    NaN    NaN    数学    87.0        10    NaN    NaN    英语    87.0</code></pre><h2 id="4-删除全是空值的列"><a href="#4-删除全是空值的列" class="headerlink" title="4.删除全是空值的列"></a>4.删除全是空值的列</h2><p>dropna就是移除空值函数，axis=columns表示删除列，how=all表示如果此列所有值都是控制则删除掉，inplace=true表示直接修改这个df</p><pre><code>    df.dropna(axis=&#39;columns&#39;,how=&#39;all&#39;,inplace=True)    df    结果：        姓名    科目    分数    0    小明    语文    85.0    1    NaN    数学    85.0    2    NaN    英语    85.0    3    NaN    NaN    NaN    4    小王    语文    86.0    5    NaN    数学    NaN    6    NaN    英语    86.0    7    NaN    NaN    NaN    8    小刘    语文    87.0    9    NaN    数学    87.0    10    NaN    英语    87.0</code></pre><p>可以看到第一列的空值已经删除，</p><h2 id="5-删除全是空值的行"><a href="#5-删除全是空值的行" class="headerlink" title="5.删除全是空值的行"></a>5.删除全是空值的行</h2><pre><code>    df.dropna(axis=&#39;index&#39;,how=&#39;all&#39;,inplace=True)    结果：        姓名    科目    分数    0    小明    语文    85.0    1    NaN    数学    85.0    2    NaN    英语    85.0    4    小王    语文    86.0    5    NaN    数学    NaN    6    NaN    英语    86.0    8    小刘    语文    87.0    9    NaN    数学    87.0    10    NaN    英语    87.0    可以看到空行已经被删除了。</code></pre><h2 id="6-将分数列为空的填充为0"><a href="#6-将分数列为空的填充为0" class="headerlink" title="6.将分数列为空的填充为0"></a>6.将分数列为空的填充为0</h2><p>fillna是填充控制的函数，需要填充的列传入参数({‘列名’：’需要替换成的值’})</p><pre><code>    df.fillna({&#39;分数&#39;:0})    结果：        姓名    科目    分数    0    小明    语文    85.0    1    NaN    数学    85.0    2    NaN    英语    85.0    4    小王    语文    86.0    5    NaN    数学    0.0    6    NaN    英语    86.0    8    小刘    语文    87.0    9    NaN    数学    87.0    10    NaN    英语    87.0    等同于：    df.loc[:,&#39;分数&#39;]=df[&#39;分数&#39;].fillna(0)</code></pre><h2 id="7-将姓名的缺失值进行填充"><a href="#7-将姓名的缺失值进行填充" class="headerlink" title="7.将姓名的缺失值进行填充"></a>7.将姓名的缺失值进行填充</h2><pre><code>    df.loc[:,&#39;姓名&#39;]=df[&#39;姓名&#39;].fillna(method=&#39;ffill&#39;)    df    结果：    姓名    科目    分数0    小明    语文    85.01    小明    数学    85.02    小明    英语    85.04    小王    语文    86.05    小王    数学    NaN6    小王    英语    86.08    小刘    语文    87.09    小刘    数学    87.010    小刘    英语    87.0</code></pre><h2 id="8-数据保存"><a href="#8-数据保存" class="headerlink" title="8.数据保存"></a>8.数据保存</h2><pre><code>    df.to_excel(r&#39;./数据清洗_清洗之后.xlsx&#39;,index=False)    index=False表示不要数据的第一列的索引。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-5</title>
    <link href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-5/"/>
    <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-5/</url>
    
    <content type="html"><![CDATA[<h1 id="六、数据分析第六课-pandas数据统计-describe"><a href="#六、数据分析第六课-pandas数据统计-describe" class="headerlink" title="六、数据分析第六课-pandas数据统计-describe"></a>六、数据分析第六课-pandas数据统计-describe</h1><a id="more"></a><h2 id="1-describe"><a href="#1-describe" class="headerlink" title="1.describe"></a>1.describe</h2><p>describe可以对数据的整体进行把控，结果包括数据数量、中位数、平均数等等。。可以看到第一列就是数据的统计值。<br>describe仅统计出表中的数据，非数据的比如字符串形式的需要用下述函数。</p><pre><code>    df.describe()    结果：        open        high        low            close        volume            jiachacount    1480.000000    1480.000000    1480.000000    1480.000000    1.480000e+03    1480.000000mean    4773.730926    4926.495608    4622.308338    4788.354784    3.711340e+05    304.187270std        5282.199856    5496.490506    5053.452625    5301.809636    6.622539e+05    585.316659min        715.860000    732.000000    500.000000    715.860000    8.422760e+01    5.20000025%        1936.000000    1997.470000    1861.500000    1942.467500    2.282406e+04    54.00000050%        2980.960000    3029.000000    2931.190000    2982.120000    6.441077e+04    109.66000075%        4847.737500    4957.507500    4713.900000    4852.300000    3.922421e+05    262.162500max        30878.76000032350.00000029651.11000030878.7600005.017736e+06    6068.600000</code></pre><h2 id="2-查看单个列的统计数据-均值、最大值、最小值"><a href="#2-查看单个列的统计数据-均值、最大值、最小值" class="headerlink" title="2.查看单个列的统计数据-均值、最大值、最小值"></a>2.查看单个列的统计数据-均值、最大值、最小值</h2><pre><code>    #open列的均值    df[&#39;open&#39;].mean()    结果：    4773.730925675672    #open列的最大值、最小值    df[&#39;open&#39;].max()    df[&#39;open&#39;].min()</code></pre><h2 id="3-唯一去重和按值计数-就是查询某列中有哪些数据，就像是set，相同的只出现一次-可以查看数据列和非数据列"><a href="#3-唯一去重和按值计数-就是查询某列中有哪些数据，就像是set，相同的只出现一次-可以查看数据列和非数据列" class="headerlink" title="3.唯一去重和按值计数(就是查询某列中有哪些数据，就像是set，相同的只出现一次)-可以查看数据列和非数据列"></a>3.唯一去重和按值计数(就是查询某列中有哪些数据，就像是set，相同的只出现一次)-可以查看数据列和非数据列</h2><h3 id="3-1唯一去重"><a href="#3-1唯一去重" class="headerlink" title="3.1唯一去重"></a>3.1唯一去重</h3><pre><code>    #非数据列    df[&#39;type&#39;].unique()    结果：    array([&#39;低&#39;, &#39;正常&#39;, &#39;高&#39;], dtype=object)    #数据列    df[&#39;open&#39;].unique()    结果：    array([  806.37,   810.6 ,   809.7 , ..., 19319.9 , 19751.  , 21988.  ])</code></pre><h3 id="3-2按值计数"><a href="#3-2按值计数" class="headerlink" title="3.2按值计数"></a>3.2按值计数</h3><p>就是查看列中都有哪种数据，然后统计各数据的个数。</p><pre><code>    #按值计数    df[&#39;type&#39;].value_counts()    结果：    低     1333    高      133    正常      14    Name: type, dtype: int64</code></pre><h2 id="4-相关系数和协方差"><a href="#4-相关系数和协方差" class="headerlink" title="4.相关系数和协方差"></a>4.相关系数和协方差</h2><p>协方差：衡量同向反向程度，协方差为正，说明两个变量同向变化，协方差越大，说明正向程度越高；协方差负的越大说明反向程度越高。<br>相关系数：就是考虑两个变量变化时的相似程度，1表示两个变量变化的正向相似程度最大，-1表示两个变量变化的反向相似程度最大。<br>实际上，相关系数就是协方差，只是将协方差的度量标准化，就是标准化的过程，比如变化相同，但是数值不同的两组数据，协方差就会相差很多，仅凭借协方差大小来评判相似程度不行，所以将其标准化后，就可以有一个评判依据，在[-1,1]这个区间中来判断两组数据的相似程度。1表示相似程度最高，-1表示最低。所以一般使用相关系数来判断。</p><h3 id="4-1协方差"><a href="#4-1协方差" class="headerlink" title="4.1协方差"></a>4.1协方差</h3><pre><code>    #协方差矩阵-整个表的协方差    df.cov()    结果：        open    high    low    close    volume    jiachaopen    2.790164e+07    2.900216e+07    2.663433e+07    2.794328e+07    -3.625104e+08    2.367831e+06high    2.900216e+07    3.021141e+07    2.770310e+07    2.910646e+07    -3.799808e+08    2.508310e+06low    2.663433e+07    2.770310e+07    2.553738e+07    2.676150e+07    -3.445158e+08    2.165714e+06close    2.794328e+07    2.910646e+07    2.676150e+07    2.810919e+07    -3.653346e+08    2.344959e+06volume    -3.625104e+08    -3.799808e+08    -3.445158e+08    -3.653346e+08    4.385803e+11    -3.546500e+07jiacha    2.367831e+06    2.508310e+06    2.165714e+06    2.344959e+06    -3.546500e+07    3.425956e+05#行与列对应，表示某两个量的协方差。</code></pre><h3 id="4-2相关系数"><a href="#4-2相关系数" class="headerlink" title="4.2相关系数"></a>4.2相关系数</h3><pre><code>    #相关系数矩阵    df.corr()    结果：        open    high    low    close    volume    jiachaopen    1.000000    0.998919    0.997789    0.997788    -0.103629    0.765852high    0.998919    1.000000    0.997366    0.998803    -0.104388    0.779659low          0.997789    0.997366    1.000000    0.998845    -0.102943    0.732187close    0.997788    0.998803    0.998845    1.000000    -0.104050    0.755649volume    -0.103629    -0.104388    -0.102943    -0.104050    1.000000    -0.091492jiacha    0.765852    0.779659    0.732187    0.755649    -0.091492    1.000000    #两个值的相关系数    df[&#39;open&#39;].corr(df[&#39;high&#39;])    结果：    0.9989185873119186</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql学习系列-1</title>
    <link href="/2020/03/28/sql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-1/"/>
    <url>/2020/03/28/sql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-1/</url>
    
    <content type="html"><![CDATA[<p>这是sql学习系列课程，hhhhh</p><a id="more"></a><h1 id="1、检索数据"><a href="#1、检索数据" class="headerlink" title="1、检索数据"></a>1、检索数据</h1><h2 id="1-1-select语句"><a href="#1-1-select语句" class="headerlink" title="1.1 select语句"></a>1.1 select语句</h2><p>大多数sql语句都使用大写的关键词,如SELCET，常用小写的来表示列名或者表名。</p><h3 id="1-1-1-检索单个列"><a href="#1-1-1-检索单个列" class="headerlink" title="1.1.1 检索单个列"></a>1.1.1 检索单个列</h3><pre><code>    SELECT 列名 FROM 表名</code></pre><h3 id="1-1-2-检索多个列"><a href="#1-1-2-检索多个列" class="headerlink" title="1.1.2 检索多个列"></a>1.1.2 检索多个列</h3><pre><code>    SELECT 列名,列名,列名 FROM 表名</code></pre><h3 id="1-1-3-检索所有列"><a href="#1-1-3-检索所有列" class="headerlink" title="1.1.3 检索所有列"></a>1.1.3 检索所有列</h3><pre><code>    SELECT * FROM 表名</code></pre><h3 id="1-1-4-检索同列中不同的值"><a href="#1-1-4-检索同列中不同的值" class="headerlink" title="1.1.4 检索同列中不同的值"></a>1.1.4 检索同列中不同的值</h3><pre><code>    SELECT DISTINCT 列名 FROM 表名</code></pre><h3 id="1-1-5-限制搜索结果"><a href="#1-1-5-限制搜索结果" class="headerlink" title="1.1.5 限制搜索结果"></a>1.1.5 限制搜索结果</h3><p>只检索某列的前五行</p><pre><code>    #sqlserver    SELECT TOP 5 列名 FROM 表名    #mysql    SELECT 列名 FROM 表名 LIMIT 5</code></pre><h3 id="1-1-6-注释"><a href="#1-1-6-注释" class="headerlink" title="1.1.6 注释"></a>1.1.6 注释</h3><pre><code>    #注释此行    /*注释    多行*/</code></pre><h1 id="2、排序检索数据"><a href="#2、排序检索数据" class="headerlink" title="2、排序检索数据"></a>2、排序检索数据</h1><h2 id="2-1-按照某个列排序"><a href="#2-1-按照某个列排序" class="headerlink" title="2.1 按照某个列排序"></a>2.1 按照某个列排序</h2><p>从某个表中选择某列，并且按照该列进行排序</p><pre><code>    SELECT 列名 FROM 表名 ORDER BY 列名</code></pre><h2 id="2-2-按照多个列名排序"><a href="#2-2-按照多个列名排序" class="headerlink" title="2.2 按照多个列名排序"></a>2.2 按照多个列名排序</h2><p>从某个表中选择多列，并且先按照列1排序，再按照列2排序，就是再列1排序的基础上，进行列2的排序。</p><pre><code>    SELECT 列名1,列名2,列名3 FROM 表名 ORDER BY 列名1，列名2</code></pre><h2 id="2-3-按照列位置排序"><a href="#2-3-按照列位置排序" class="headerlink" title="2.3 按照列位置排序"></a>2.3 按照列位置排序</h2><p>选择列名1,列名2,列名3  3列，按照先列名2，再列名3的顺序排序</p><pre><code>    SELECT 列名1,列名2,列名3 FROM 表名 ORDER BY 2，3</code></pre><h1 id="3、过滤数据"><a href="#3、过滤数据" class="headerlink" title="3、过滤数据"></a>3、过滤数据</h1><h2 id="3-1使用WHERE语句"><a href="#3-1使用WHERE语句" class="headerlink" title="3.1使用WHERE语句"></a>3.1使用WHERE语句</h2><p>检索列1和列2但是不返回所有的行，仅返回列1=某值得那行</p><pre><code>    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 = 某值    #也可以选择不满足条件的值，常用符号&lt;&gt;或者！=    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 &lt;&gt; 某值</code></pre><h2 id="3-2范围值检查"><a href="#3-2范围值检查" class="headerlink" title="3.2范围值检查"></a>3.2范围值检查</h2><p>检索满足列1中的值处于范围5到10条件的行</p><pre><code>    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 BETWEEN 5 AND 10</code></pre><h2 id="3-3空值检查"><a href="#3-3空值检查" class="headerlink" title="3.3空值检查"></a>3.3空值检查</h2><p>检索空值</p><pre><code>    SELECT 列 FROM 表 WHERE 列 IS NULL</code></pre><h1 id="4高级数据过滤"><a href="#4高级数据过滤" class="headerlink" title="4高级数据过滤"></a>4高级数据过滤</h1><h2 id="4-1组合WHERE子句"><a href="#4-1组合WHERE子句" class="headerlink" title="4.1组合WHERE子句"></a>4.1组合WHERE子句</h2><h3 id="4-1-1-AND操作符"><a href="#4-1-1-AND操作符" class="headerlink" title="4.1.1 AND操作符"></a>4.1.1 AND操作符</h3><p>AND操作符表示检索同时满足两个条件的行</p><pre><code>    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 = 某值 AND 列名2 &lt;= 某值</code></pre><h3 id="4-1-2-OR操作符"><a href="#4-1-2-OR操作符" class="headerlink" title="4.1.2 OR操作符"></a>4.1.2 OR操作符</h3><p>OR操作符表示检索满足两个条件中的任意一个就行</p><pre><code>    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 = 某值 OR 列名2 &lt;= 某值</code></pre><h3 id="4-1-3-IN操作符"><a href="#4-1-3-IN操作符" class="headerlink" title="4.1.3 IN操作符"></a>4.1.3 IN操作符</h3><p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<br>就是选择后面括号中的任一个，相当于OR</p><pre><code>    #下面两个语句将实现相同的结果    SELECT prod_name, prod_price FROM Products WHERE vend_id IN ( &#39;DLL01&#39;, &#39;BRS01&#39; ) ORDER BY prod_name    和    SELECT prod_name, prod_price FROM Products WHERE vend_id = &#39;DLL01&#39; OR vend_id = &#39;BRS01&#39; ORDER BY prod_name; </code></pre><h3 id="4-1-4-NOT操作符"><a href="#4-1-4-NOT操作符" class="headerlink" title="4.1.4 NOT操作符"></a>4.1.4 NOT操作符</h3><p>NOT操作符有且只有一个功能，就是否定后面跟的任何条件。</p><pre><code>    #取列名1不等于某值的行    SELECT 列名1,列名2 FROM 表名 WHERE NOT 列名1 = 某值    #与下式等价    SELECT 列名1,列名2 FROM 表名 WHERE 列名1 &lt;&gt; 某值</code></pre><h1 id="5、用通配符进行过滤"><a href="#5、用通配符进行过滤" class="headerlink" title="5、用通配符进行过滤"></a>5、用通配符进行过滤</h1><h2 id="5-1-LIKE操作符"><a href="#5-1-LIKE操作符" class="headerlink" title="5.1 LIKE操作符"></a>5.1 LIKE操作符</h2><h3 id="5-1-1-百分号-通配符"><a href="#5-1-1-百分号-通配符" class="headerlink" title="5.1.1 百分号(%)通配符"></a>5.1.1 百分号(%)通配符</h3><pre><code>    SELECT prod_id, prod_name  FROM Products  WHERE prod_name LIKE &#39;Fish%&#39;    #此例子使用了搜索模式&#39;Fish%&#39;。在执行这条子句时，将检索任意以Fish 起头的词。%告诉 DBMS接受 Fish 之后的任意字符，不管它有多少字符    结果:    prod_id     prod_name     -------        ------    BNBG01      Fish bean bag toy    SELECT prod_id, prod_name  FROM Products  WHERE prod_name LIKE &#39;%Fish%&#39;    #表示检索中间有Fish的条件，不管前面和后面有多少字符</code></pre><h3 id="5-1-2下划线通配符"><a href="#5-1-2下划线通配符" class="headerlink" title="5.1.2下划线通配符"></a>5.1.2下划线通配符</h3><p>与%能匹配 0个字符不同，下划线总是刚好匹配一个字符，不能多也不能少</p><h3 id="5-1-3方括号-通配符"><a href="#5-1-3方括号-通配符" class="headerlink" title="5.1.3方括号([])通配符"></a>5.1.3方括号([])通配符</h3><pre><code>    #找出所有名字以 J 或 M 起头的联系人，可进行如下查询：     FROM Customers WHERE cust_contact LIKE &#39;[JM]%&#39; ORDER BY cust_contac    #若是查询除了J或M起头的联系人：    [^JM]</code></pre><h1 id="6-联结表–重要"><a href="#6-联结表–重要" class="headerlink" title="6.联结表–重要"></a>6.联结表–重要</h1><p>数据一般都按照特定的结构分解存在不同的表中，所以查询的时候就可以使用一条SELECT语句来将需要的不同的表中的信息关联起来查询。<br>创建联结表：指定要联结的所有表以及关联他们的方式即可。<br>注意：联结表需要使</p><pre><code>    SELECT 列1，列1，列3 FROM 表1，表2 WHERE 表1.列1 = 表2.列1</code></pre><h2 id="6-1联结多个表"><a href="#6-1联结多个表" class="headerlink" title="6.1联结多个表"></a>6.1联结多个表</h2><p>联结多个表用AND联结</p><pre><code>    SELECT prod_name, vend_name, prod_price, quantity FROM OrderItems, Products, Vendors WHERE Products.vend_id = Vendors.vend_id  AND OrderItems.prod_id = Products.prod_id  AND order_num = 20007;</code></pre><h1 id="7-插入数据"><a href="#7-插入数据" class="headerlink" title="7.插入数据"></a>7.插入数据</h1><p>主要的就是INSERT语句</p><h2 id="7-1插入完整的行"><a href="#7-1插入完整的行" class="headerlink" title="7.1插入完整的行"></a>7.1插入完整的行</h2><p>将指定的行插入指定的表中，将值1,2,3，..插入到表中的新行中，等于插入新的数据行</p><pre><code>    INSERT INTO 表名 VALUES(&#39;值1&#39;，&#39;值2&#39;,&#39;值3&#39;，...&#39;值N&#39;)</code></pre><p>上述值1，值2..的顺序应该按照表中列名的顺序来安排，但是这样容易出问题，应尽量将列名也带上，可以防止出错。</p><pre><code>    INSERT INTO 表名(列名1，列名2，...列名N) VALUES(&#39;值1&#39;，&#39;值2&#39;,&#39;值3&#39;，...&#39;值N&#39;)</code></pre><h2 id="7-2插入部分行"><a href="#7-2插入部分行" class="headerlink" title="7.2插入部分行"></a>7.2插入部分行</h2><p>插入新行中的前三列，其他列默认是NULL</p><pre><code>    INSERT INTO 表名(列名1，列名2，列名3) VALUES(&#39;值1&#39;，&#39;值2&#39;,&#39;值3&#39;)</code></pre><h2 id="7-3插入检索出的数据"><a href="#7-3插入检索出的数据" class="headerlink" title="7.3插入检索出的数据"></a>7.3插入检索出的数据</h2><p>将表2中的列的值，插入到表1中，(复制表格时好用。)</p><pre><code>    INSERT INTO 表1(列名1，列名2，列名3) SELCET 列1，列2，列3 FROM 表2</code></pre><h2 id="7-4从一个表复制到另一个表"><a href="#7-4从一个表复制到另一个表" class="headerlink" title="7.4从一个表复制到另一个表"></a>7.4从一个表复制到另一个表</h2><p>将表2复制到表1</p><pre><code>    SELECT * INTO 表1 FROM 表2</code></pre><h1 id="8-更新数据库"><a href="#8-更新数据库" class="headerlink" title="8.更新数据库"></a>8.更新数据库</h1><p>主要就是UPDATE语句，基本的UPDATE语句由三部分组成：<br>要更新的表；<br>列名和它们的新值；<br>确定要更新哪些行的过滤条件。 </p><pre><code>    UPDATE 表1 SET 列1 = &#39;值1&#39;,列3=&#39;值3&#39; WHERE 列名2 = &#39;值2&#39;     #更新表1中，列2为值2行，中的列1更新为值1 和 列3更新为值3</code></pre><h1 id="9-删除数据"><a href="#9-删除数据" class="headerlink" title="9.删除数据"></a>9.删除数据</h1><p>DELETE语句<br>删除表1中，列1为值1的 数据行，（删除的是行）</p><pre><code>    DELETE FROM 表1 WHERE 列1 = 值1</code></pre><h1 id="10-创建和操纵表"><a href="#10-创建和操纵表" class="headerlink" title="10.创建和操纵表"></a>10.创建和操纵表</h1><h2 id="10-1创建表"><a href="#10-1创建表" class="headerlink" title="10.1创建表"></a>10.1创建表</h2><p>创建规则：CREATE TABLE + 表名，然后后面括号跟一个列名 + 数据类型 + 是否允许空值。NULL表示可以是空值，这样在插入数据时候，此处可以是空值。NOT NULL表示不可以是空值，这样在插入数据的时候不能是空值，如果是空值则返回错误。</p><pre><code>    CREATE TABLE Orders (order_num      INTEGER      NOT NULL,                         order_date     DATETIME     NOT NULL,                              cust_id        CHAR(10)     NOT NULL )</code></pre><h2 id="10-2删除表"><a href="#10-2删除表" class="headerlink" title="10.2删除表"></a>10.2删除表</h2><pre><code>    DROP TABLE 表名</code></pre><h1 id="11-使用视图"><a href="#11-使用视图" class="headerlink" title="11.使用视图"></a>11.使用视图</h1><p>视图的作用就是将多个表中的数据提取出来，其实就是先将允许需要的数据提取出来，放在一个视图中，然后从视图中进行查询。注意视图中不包含数据，每次使用视图时候，都要处理查询语句执行的所有检索，可能性能会受到影响，所以之前应该先进行测试。<br>视图作用：重用SQL语句、简化SQL操作、保护数据、使用数据的一部分而不是整个表、更改数据格式和表示、可以将数据集合一起后，重复使用视图，简化繁琐的查询语句。</p><pre><code>    #创建一个视图：    CREAT VIEW 视图名字    #删除一个视图：    DROP VIEW 视图名字</code></pre><p>例子(创建一个视图）：</p><pre><code>    CREATE VIEW ProductCustomers AS     SELECT cust_name, cust_contact, prod_id     FROM Customers, Orders, OrderItems     WHERE Customers.cust_id = Orders.cust_id      AND OrderItems.order_num = Orders.order_num; </code></pre><p>例子(使用上述视图)：</p><pre><code>    SELECT cust_name, cust_contact     FROM ProductCustomers     WHERE prod_id = &#39;RGAN01&#39;</code></pre><h1 id="12-游标"><a href="#12-游标" class="headerlink" title="12.游标"></a>12.游标</h1><p>没看懂要干啥</p><h1 id="13-高级SQL特性"><a href="#13-高级SQL特性" class="headerlink" title="13.高级SQL特性"></a>13.高级SQL特性</h1><h2 id="13-1主键"><a href="#13-1主键" class="headerlink" title="13.1主键"></a>13.1主键</h2><p>创建主键就是在创建表的某列的后面添加PRIMARY KEY，该字段就是主键</p><pre><code>    CREATE TABLE Vendors  (vend_id         CHAR(10)       NOT NULL PRIMARY KEY,                              vend_name       CHAR(50)       NOT NULL,                                        vend_address    CHAR(50)       NULL,                                vend_city       CHAR(50)       NULL,                                vend_state      CHAR(5)        NULL,                                vend_zip        CHAR(10)       NULL,                                vend_country    CHAR(50)       NULL )</code></pre><h2 id="13-2外键"><a href="#13-2外键" class="headerlink" title="13.2外键"></a>13.2外键</h2><p>外键就是两个表进行连接的时候非主键的表，比如表1中的顾客ID与表2中的顾客ID，顾客ID都不是表的主键，而要连接两个表，所以就要使用外键，使表1与表2的顾客ID相等就可以。</p><pre><code>    #创建表的时候创建外键    CREATE TABLE Orders (order_num     INTEGER     NOT NULL PRIMARY KEY,                                  order_date    DATETIME    NOT NULL,                          cust_id       CHAR(10)    NOT NULL REFERENCES  Customers(cust_id) )</code></pre><p>表示cust_id中的任何值都必须是Customers表的cust_id中的值。</p><pre><code>    #创建外键    #    ALTER TABLE Orders    ADD CONSTRAINT    FOREIGN KEY (cust_id) REFERENCES Customers (cust_id) </code></pre><h2 id="13-3创建检查约束"><a href="#13-3创建检查约束" class="headerlink" title="13.3创建检查约束"></a>13.3创建检查约束</h2><p>检查名为 gender 的列只包含 M 或 F，可编写如下的 ALTER TABLE 语句：</p><pre><code>    ADD CONSTRAINT CHECK (gender LIKE &#39;[MF]&#39;) </code></pre><h1 id="好了结束了，看不懂的和感觉没有用的就没添加了，好吧！"><a href="#好了结束了，看不懂的和感觉没有用的就没添加了，好吧！" class="headerlink" title="好了结束了，看不懂的和感觉没有用的就没添加了，好吧！"></a>好了结束了，看不懂的和感觉没有用的就没添加了，好吧！</h1><p>继续加油！</p>]]></content>
    
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-路线</title>
    <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="零数据分析路线图–持续更新"><a href="#零数据分析路线图–持续更新" class="headerlink" title="零数据分析路线图–持续更新"></a>零数据分析路线图–持续更新</h1><a id="more"></a><p>数据分析师需要掌握的技术:</p><h2 id="1-统计学—-已经掌握"><a href="#1-统计学—-已经掌握" class="headerlink" title="1.统计学—-已经掌握"></a>1.统计学—-已经掌握</h2><p>描述统计，统计推断，概率论；<br>抽样，分布，估计，置信区间，假设检验；<br>线性回归，时间序列；<br>这部分的知识已经基本具备了，问题不大，以后再有问题可以直接百度。</p><h2 id="2-SQL语言—-目前尚未完全掌握，仅会基本的一些语句"><a href="#2-SQL语言—-目前尚未完全掌握，仅会基本的一些语句" class="headerlink" title="2.SQL语言—-目前尚未完全掌握，仅会基本的一些语句"></a>2.SQL语言—-目前尚未完全掌握，仅会基本的一些语句</h2><p>SQL语言主要用于操作数据库，SQL的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p><h2 id="3-EXCEL基本操作—-目前具备基本的EXCEL操作技能"><a href="#3-EXCEL基本操作—-目前具备基本的EXCEL操作技能" class="headerlink" title="3.EXCEL基本操作—-目前具备基本的EXCEL操作技能"></a>3.EXCEL基本操作—-目前具备基本的EXCEL操作技能</h2><p>因为公司很多其它部门非技术人员是不会使用编程工具的，而会使用相对简单的Excel来处理一些报表。这个时候就可能需要你可以在Excel中做一些数据分析工作然后反馈，但是也不必太深入，掌握核心的功能即可。</p><h2 id="4-PYTHON语言或者R语言—-python语言基本语法已经掌握，目前在学pandas"><a href="#4-PYTHON语言或者R语言—-python语言基本语法已经掌握，目前在学pandas" class="headerlink" title="4.PYTHON语言或者R语言—-python语言基本语法已经掌握，目前在学pandas"></a>4.PYTHON语言或者R语言—-python语言基本语法已经掌握，目前在学pandas</h2><p>主要包括python中的pandas库和numpy库和matplotlib库，<br>pandas主要用于数据处理，numpy主要用于数据计算，matplotlib主要用于可视化。<br>目前学习pandas。</p><h2 id="5-爬虫—-目前简单一点的网站都可以爬到，scrapy待学习"><a href="#5-爬虫—-目前简单一点的网站都可以爬到，scrapy待学习" class="headerlink" title="5.爬虫—-目前简单一点的网站都可以爬到，scrapy待学习"></a>5.爬虫—-目前简单一点的网站都可以爬到，scrapy待学习</h2><p>目前主要需要学习的就是scrapy框架，这个框架挺重要的，感觉是爬虫必备的库。</p><h2 id="6-机器学习—-进阶内容，与pandas和numpy有交叉"><a href="#6-机器学习—-进阶内容，与pandas和numpy有交叉" class="headerlink" title="6.机器学习—-进阶内容，与pandas和numpy有交叉"></a>6.机器学习—-进阶内容，与pandas和numpy有交叉</h2><p>机器学习主要学习各种算法，实际上就已经到了数据挖掘的领域了，属于进阶内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-4</title>
    <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-4/"/>
    <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-4/</url>
    
    <content type="html"><![CDATA[<h1 id="五、数据分析第五课-pandas查询数据-loc、iloc"><a href="#五、数据分析第五课-pandas查询数据-loc、iloc" class="headerlink" title="五、数据分析第五课-pandas查询数据-loc、iloc"></a>五、数据分析第五课-pandas查询数据-loc、iloc</h1><a id="more"></a><h2 id="1-查询数据"><a href="#1-查询数据" class="headerlink" title="1.查询数据"></a>1.查询数据</h2><p>##　loc查询通用公式:df.loc[‘条件’,’列名’]<br>###　1.0读取数据</p><pre><code>    import pandas as pd    df = pd.read_csv(&quot;./daily_price_btc_cny.csv&quot;)    df.head()    结果:    date    open    high    low    close    volume0    2013/9/1    806.37    815.0    803.20    811.42    84.22761    2013/9/2    810.60    816.7    801.00    811.00    317.12062    2013/9/3    809.70    812.0    797.90    801.37    304.01733    2013/9/4    801.00    802.2    797.00    798.20    308.53004    2013/9/5    800.00    802.0    663.27    752.30    1016.1104</code></pre><h3 id="1-1数据初步替换"><a href="#1-1数据初步替换" class="headerlink" title="1.1数据初步替换"></a>1.1数据初步替换</h3><p>替换1-3行的字符，将/替换为-</p><pre><code>    #将日期中的/替换为- 1:3表示只替换第一行到第三行    df.loc[1:3,&#39;date&#39;] = df[&#39;date&#39;].str.replace(&quot;/&quot;,&quot;-&quot;)    df.head()    结果:    date    open    high    low    close    volume0    2013/9/1    806.37    815.0    803.20    811.42    84.22761    2013-9-2    810.60    816.7    801.00    811.00    317.12062    2013-9-3    809.70    812.0    797.90    801.37    304.01733    2013-9-4    801.00    802.2    797.00    798.20    308.53004    2013/9/5    800.00    802.0    663.27    752.30    1016.1104    替换所有行    # ：表示替换所有行    df.loc[:,&#39;date&#39;] = df[&#39;date&#39;].str.replace(&quot;/&quot;,&quot;-&quot;)    df.head()</code></pre><h3 id="1-2查询某行多列的数据"><a href="#1-2查询某行多列的数据" class="headerlink" title="1.2查询某行多列的数据"></a>1.2查询某行多列的数据</h3><p>查询2013-9-1行的open、high列的两个数据</p><pre><code>    df.set_index(&#39;date&#39;,inplace=True)    df.loc[&#39;2013-9-1&#39;,[&#39;open&#39;,&#39;high&#39;]]    结果:    open    806.37    high    815.00    Name: 2013-9-1, dtype: float64</code></pre><h3 id="1-3查询多行多列的数据"><a href="#1-3查询多行多列的数据" class="headerlink" title="1.3查询多行多列的数据"></a>1.3查询多行多列的数据</h3><p>查询2013-9-1’,’2013-9-2两行和open、high四个数据</p><pre><code>    df.loc[[&#39;2013-9-1&#39;,&#39;2013-9-2&#39;],[&#39;open&#39;,&#39;high&#39;]]    结果:                open    high    date            2013-9-1    806.37    815.0    2013-9-2    810.60    816.7</code></pre><h3 id="1-4使用数据区间进行查询"><a href="#1-4使用数据区间进行查询" class="headerlink" title="1.4使用数据区间进行查询"></a>1.4使用数据区间进行查询</h3><p>查询2013-9-1到2013-9-2的open到high的数据</p><pre><code>    df.loc[&#39;2013-9-1&#39;:&#39;2013-9-2&#39;,&#39;open&#39;:&#39;close&#39;]                open    high    low    close    date                    2013-9-1    806.37    815.0    803.2    811.42    2013-9-2    810.60    816.7    801.0    811.00</code></pre><h3 id="1-5使用条件表达式查询（-gt-、-lt-之类的）"><a href="#1-5使用条件表达式查询（-gt-、-lt-之类的）" class="headerlink" title="1.5使用条件表达式查询（&gt;、&lt;之类的）"></a>1.5使用条件表达式查询（&gt;、&lt;之类的）</h3><p>查询所有行中open&lt;10000的数据，“df[‘open’]&lt;10000”是查询条件，:表示选择所有列</p><pre><code>    df.loc[df[&#39;open&#39;]&lt;10000,:]    #两个条件用&amp;    df.loc[(df[&#39;open&#39;]&lt;10000)&amp;(df[&#39;high&#39;]&gt;9000),:]</code></pre><h2 id="2-新增数据列"><a href="#2-新增数据列" class="headerlink" title="2.新增数据列"></a>2.新增数据列</h2><h3 id="2-1直接赋值方法，新增数据列"><a href="#2-1直接赋值方法，新增数据列" class="headerlink" title="2.1直接赋值方法，新增数据列"></a>2.1直接赋值方法，新增数据列</h3><pre><code>    #新增一个最高价格与最低价格差的列“jiacha”=最高价-最低价，赋值给所有行    df.loc[:,&#39;jiacha&#39;]=df[&#39;high&#39;]-df[&#39;low&#39;]    df.head()</code></pre><h3 id="2-2-df-apply方法"><a href="#2-2-df-apply方法" class="headerlink" title="2.2 df.apply方法"></a>2.2 df.apply方法</h3><p>apply方法就是可以创建一个条件函数，将条件封装在函数里，然后创建符合条件的列<br>如下：先创建一个type函数，df.apply(type,axis=1)表示创建一个</p><pre><code>    #axis=1表示添加列    def type(x):        if x[&#39;open&#39;]&gt;9000:            return &#39;高&#39;        if x[&#39;open&#39;]&lt;8000:            return &#39;低&#39;        return &#39;正常&#39;    df.loc[:,&#39;type&#39;] = df.apply(type,axis=1)    df.head()</code></pre><h3 id="2-3按条件分组分别赋值"><a href="#2-3按条件分组分别赋值" class="headerlink" title="2.3按条件分组分别赋值"></a>2.3按条件分组分别赋值</h3><pre><code>    #先创建空列    df[&#39;price_cha&#39;]=&#39;&#39;    df.loc[df[&#39;high&#39;]-df[&#39;low&#39;]&gt;1000,&#39;price_cha&#39;] = &#39;价格差别大&#39;    df.loc[df[&#39;high&#39;]-df[&#39;low&#39;]&lt;100,&#39;price_cha&#39;] = &#39;价格差别小&#39;    df.head()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-3</title>
    <link href="/2020/03/26/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-3/"/>
    <url>/2020/03/26/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-3/</url>
    
    <content type="html"><![CDATA[<h1 id="四、数据分析第四课-pandas"><a href="#四、数据分析第四课-pandas" class="headerlink" title="四、数据分析第四课-pandas"></a>四、数据分析第四课-pandas</h1><a id="more"></a><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1.Series"></a>1.Series</h2><h3 id="1-1创建series"><a href="#1-1创建series" class="headerlink" title="1.1创建series"></a>1.1创建series</h3><p>series就是左边是索引，右边是数据的数据结构，索引可以自定义，默认是从0到n-1<br>注意Series的S是大写的</p><pre><code>    import pandas as pd    series1 = pd.Series([1,2,3,4],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])    series1    结果：    a    1    b    2    c    3    d    4    dtype: int64</code></pre><h3 id="1-2字典转换为series"><a href="#1-2字典转换为series" class="headerlink" title="1.2字典转换为series"></a>1.2字典转换为series</h3><p>就是将字典转换为series，键是index，值是数值。</p><pre><code>    sdata={&#39;Ohio&#39;:    35000,    &#39;Texas&#39;:    71000,    &#39;Oregon&#39;:    16000,    &#39;Utah&#39;:    5000}    obj3    =    pd.Series(sdata)    obj3    结果:    Ohio      35000    Texas     71000    Oregon    16000    Utah       5000    dtype: int64</code></pre><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2.DataFrame"></a>2.DataFrame</h2><p>DataFrame是⼀个表格型的数据结构，它含有⼀组有序的列，每列可以是不同的值类型（数值、字符 串、布尔值等）。DataFrame既有⾏索引也有列索引，它可以被看做由Series组成的字典（共⽤同⼀ 个索引）。DataFrame中的数据是以⼀个或多个⼆维块存放的（⽽不是列表、字典或别的⼀维数据结 构）</p><h3 id="2-1创建DataFrame"><a href="#2-1创建DataFrame" class="headerlink" title="2.1创建DataFrame"></a>2.1创建DataFrame</h3><p>建DataFrame的办法有很多，最常⽤的⼀种是直接传⼊⼀个由等⻓列表或NumPy数组组成的字典：</p><pre><code>    data={&#39;state&#39;:[&#39;Ohio&#39;,&#39;Ohio&#39;,&#39;Ohio&#39;,&#39;Nevada&#39;,&#39;Nevada&#39;,&#39;Nevada&#39;],         &#39;year&#39;:[2000,2001,2002,2001,2002,2003],         &#39;pop&#39;:[1.5,1.7,3.6,2.4,2.9,3.2]}     frame=pd.DataFrame(data)    frame    结果:        state    year    pop    0    Ohio    2000    1.5    1    Ohio    2001    1.7    2    Ohio    2002    3.6    3    Nevada    2001    2.4    4    Nevada    2002    2.9    5    Nevada    2003    3.2</code></pre><p>指定列的排序方式,并且指定index索引</p><pre><code>    data2 = pd.DataFrame(data,columns=[&#39;year&#39;,&#39;state&#39;,&#39;pop&#39;],index=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;,&#39;six&#39;])    data2    结果:        year    state    pop    one    2000    Ohio    1.5    two    2001    Ohio    1.7    three    2002    Ohio    3.6    four    2001    Nevada    2.4    five    2002    Nevada    2.9    six    2003    Nevada    3.2</code></pre><h3 id="2-2取出字典某列作为series"><a href="#2-2取出字典某列作为series" class="headerlink" title="2.2取出字典某列作为series"></a>2.2取出字典某列作为series</h3><pre><code>    data2[&#39;year&#39;]    结果：    one      2000    two      2001    three    2002    four     2001    five     2002    six      2003    Name: year, dtype: int64</code></pre><h3 id="2-3为不存在的列赋值会创建出⼀个新列。"><a href="#2-3为不存在的列赋值会创建出⼀个新列。" class="headerlink" title="2.3为不存在的列赋值会创建出⼀个新列。"></a>2.3为不存在的列赋值会创建出⼀个新列。</h3><p>关键字del⽤于删除列。</p><pre><code>    del data2[&#39;pop&#39;]    data2    结果：        year    state    one    2000    Ohio    two    2001    Ohio    three    2002    Ohio    four    2001    Nevada    five    2002    Nevada    six    2003    Nevada</code></pre><h3 id="2-4嵌套字典，如下字典格式，外层字典的键“nevada”、“ohio”作为列，内层键”2001”、”2002”则作为⾏索引。"><a href="#2-4嵌套字典，如下字典格式，外层字典的键“nevada”、“ohio”作为列，内层键”2001”、”2002”则作为⾏索引。" class="headerlink" title="2.4嵌套字典，如下字典格式，外层字典的键“nevada”、“ohio”作为列，内层键”2001”、”2002”则作为⾏索引。"></a>2.4嵌套字典，如下字典格式，外层字典的键“nevada”、“ohio”作为列，内层键”2001”、”2002”则作为⾏索引。</h3><pre><code>        pop    =    {&#39;Nevada&#39;:    {2001:    2.4,    2002:    2.9},                              &#39;Ohio&#39;:    {2000:    1.5,    2001:    1.7,2002:    3.6}}        frame = pd.DataFrame(pop)        frame        结果：          Nevada    Ohio    2000    NaN        1.5    2001    2.4        1.7    2002    2.9        3.6</code></pre><h3 id="2-5-DataFrame转置-交换行和列"><a href="#2-5-DataFrame转置-交换行和列" class="headerlink" title="2.5 DataFrame转置(交换行和列)"></a>2.5 DataFrame转置(交换行和列)</h3><pre><code>    frame.T    结果：        2000    2001    2002Nevada    NaN        2.4        2.9Ohio    1.5        1.7        3.6</code></pre><h3 id="2-6设置DataFrame的index和column的名，就像是表左上角的索引名和行名"><a href="#2-6设置DataFrame的index和column的名，就像是表左上角的索引名和行名" class="headerlink" title="2.6设置DataFrame的index和column的名，就像是表左上角的索引名和行名"></a>2.6设置DataFrame的index和column的名，就像是表左上角的索引名和行名</h3><pre><code>    frame.index.name=&#39;索引名&#39;;frame.columns.name=&#39;行名&#39;    frame    结果：    行名        Nevada    Ohio    索引名            2000    NaN        1.5    2001    2.4        1.7    2002    2.9        3.6</code></pre><h3 id="2-7-values属性"><a href="#2-7-values属性" class="headerlink" title="2.7 values属性"></a>2.7 values属性</h3><p>values属性会以⼆维ndarray的形式返回DataFrame中的数据，就是直接返回dataframe中的数据，去掉了index和columns，输出表格数据</p><pre><code>    frame.values    结果：    array([[nan, 1.5],           [2.4, 1.7],           [2.9, 3.6]])</code></pre><h2 id="3-pandas基本功能"><a href="#3-pandas基本功能" class="headerlink" title="3 pandas基本功能"></a>3 pandas基本功能</h2><h3 id="3-1-reindex，对索引进行重命名"><a href="#3-1-reindex，对索引进行重命名" class="headerlink" title="3.1 reindex，对索引进行重命名"></a>3.1 reindex，对索引进行重命名</h3><p>对索引进行重排，按照原来的键值对，对应新的索引顺序进行排列，如果原键值对没有，<br>则赋值为NaN</p><pre><code>    obj    =    pd.Series([4.5,    7.2,-5.3,3.6],index=[&#39;d&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;])    obj2    =    obj.reindex([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])    obj2    结果：    a   -5.3    b    7.2    c    3.6    d    4.5    e    NaN</code></pre><h3 id="3-2-drop移除某行或者某列"><a href="#3-2-drop移除某行或者某列" class="headerlink" title="3.2 drop移除某行或者某列"></a>3.2 drop移除某行或者某列</h3><p>drop(‘index’)移除某行<br>drop(‘column’,’axis=1’)</p><pre><code>    移除某行    obj3 = obj2.drop(&#39;b&#39;)    obj3    结果：    a   -5.3    c    3.6    d    4.5    e    NaN    移除某列    frame2 = frame.drop(&#39;Ohio&#39;,axis=1)    frame2    结果：            Nevada    2000    NaN    2001    2.4    2002    2.9</code></pre><h3 id="3-3-索引"><a href="#3-3-索引" class="headerlink" title="3.3 索引"></a>3.3 索引</h3><p>直接索引某个index的值，也可以切片索引</p><pre><code>    obj    =    pd.Series(np.arange(4.),index=[&#39;a&#39;,    &#39;b&#39;,&#39;c&#39;,&#39;d&#39;])    obj[&#39;b&#39;]    结果：    1.0    obj[1:2]    结果：    b    1.0    obj[&#39;a&#39;:&#39;b&#39;]    a    0.0    b    1.0</code></pre><p>注意使用数字索引和index索引的结果不同，数字索引左闭右开，index索引左右都是闭合的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-2</title>
    <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-2/"/>
    <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-2/</url>
    
    <content type="html"><![CDATA[<h1 id="三、数据分析第三课-python基本数据结构"><a href="#三、数据分析第三课-python基本数据结构" class="headerlink" title="三、数据分析第三课-python基本数据结构"></a>三、数据分析第三课-python基本数据结构</h1><a id="more"></a><h2 id="1数据结构和序列"><a href="#1数据结构和序列" class="headerlink" title="1数据结构和序列"></a>1数据结构和序列</h2><h3 id="1-1元组"><a href="#1-1元组" class="headerlink" title="1.1元组"></a>1.1元组</h3><p>元组是⼀个固定⻓度，不可改变的Python序列对象。创建元组的最简单⽅式，是⽤逗号分隔⼀列值：</p><h4 id="1-1-1创建"><a href="#1-1-1创建" class="headerlink" title="1.1.1创建"></a>1.1.1创建</h4><pre><code>    #tuple--元组，创建非常简单，直接用逗号就可以了,或者是用括号+逗号    #创建tuple    tup1 = (4,5,6)    type(tup1)    tup2 = 1,2,3    type(tup2)</code></pre><h4 id="1-1-2将列表转换为tuple"><a href="#1-1-2将列表转换为tuple" class="headerlink" title="1.1.2将列表转换为tuple"></a>1.1.2将列表转换为tuple</h4><pre><code>    #将列表转换为tuple    b = [1,2,3]    a = tuple(a)    type(a)</code></pre><h4 id="1-1-3tuple没法直接修改，没有append、delete，只要创建了就不可改变。"><a href="#1-1-3tuple没法直接修改，没有append、delete，只要创建了就不可改变。" class="headerlink" title="1.1.3tuple没法直接修改，没有append、delete，只要创建了就不可改变。"></a>1.1.3tuple没法直接修改，没有append、delete，只要创建了就不可改变。</h4><p>但是tuple中如果包含可以改变的数组比如list，可以修改list中的内容</p><pre><code>    c = ([1,2,3],5)    c[0].append(4)    c    结果：    ([1, 2, 3, 4], 5)</code></pre><h4 id="1-1-4元组可以使用“-”直接将两个元组加起来"><a href="#1-1-4元组可以使用“-”直接将两个元组加起来" class="headerlink" title="1.1.4元组可以使用“+”直接将两个元组加起来"></a>1.1.4元组可以使用“+”直接将两个元组加起来</h4><pre><code>    d = 1,2,3    e = 4,5,6    d+e    结果：    (1, 2, 3, 4, 5, 6)</code></pre><h4 id="1-1-5元组拆分："><a href="#1-1-5元组拆分：" class="headerlink" title="1.1.5元组拆分："></a>1.1.5元组拆分：</h4><pre><code>    #元组拆分    f = 1,2,3    a,b,c=f    a    结果：    1</code></pre><h3 id="1-2列表"><a href="#1-2列表" class="headerlink" title="1.2列表"></a>1.2列表</h3><p>除去一些基本功能，将不知道的list功能记录一下</p><h4 id="1-2-1添加和删除元素"><a href="#1-2-1添加和删除元素" class="headerlink" title="1.2.1添加和删除元素"></a>1.2.1添加和删除元素</h4><p>apend、insert、pop、remove</p><pre><code>    #append在末尾添加元素，在某地插入元素用insert    list_1 = [1,2,3,5]    list_1.insert(3,4)    list_1    结果：    [1, 2, 3, 4, 5]    #删除元素--pop    #insert的逆运算是pop，删除第几个元素    list_1.pop(0)    list_1    结果    [2,3,4,5]    #删除元素--remove    #remove删除某个值，默认移除找到的第一个值    list_2 = [1,2,3,4,5,6,&quot;aaa&quot;]    list_2.remove(&quot;aaa&quot;)    list_2    结果：    [1,2,3,4,5,6]</code></pre><h4 id="1-2-2-extend函数"><a href="#1-2-2-extend函数" class="headerlink" title="1.2.2 extend函数"></a>1.2.2 extend函数</h4><p>如果已经定义了一个列表，使用append可以添加元素，使用extend可以追加多个元素，可以追加另一个列表，</p><pre><code>    everything    =    []     for    chunk    in    list_of_lists:                        everything.extend(chunk)    #extend比下述方法更快    everything    =    []     for    chunk    in    list_of_lists:                        everything    =    everything    +    chunk</code></pre><h4 id="1-2-3排序"><a href="#1-2-3排序" class="headerlink" title="1.2.3排序"></a>1.2.3排序</h4><p>sort()函数</p><pre><code>    #sort函数    a = [1,2,5,4,3,5,8,1,]    a.sort()    a    结果：    [1, 1, 2, 3, 4, 5, 5, 8]</code></pre><h4 id="1-2-4切片"><a href="#1-2-4切片" class="headerlink" title="1.2.4切片"></a>1.2.4切片</h4><p>正向切片的结果是左闭右开的</p><pre><code>    #切片    b = [1,2,3,4,5,6,7,8,9]    b[1:5]    结果：    [2, 3, 4, 5]</code></pre><p>反向切片的结果也是左开右闭的，因为负数切片也是从0(就是从右边）开始，然后从右往左数，第一个是0，第一个是-1，，，，[-5:-1],从右边开始数，第一个数是-1，闭合，第二个是-5就是开的。先数到的那个数是闭合的，后数到的就是开的</p><pre><code>    #切片    b = [1,2,3,4,5,6,7,8,9]    b[-5:-1]    结果：    [5, 6, 7, 8]</code></pre><h4 id="1-2-5-zip函数"><a href="#1-2-5-zip函数" class="headerlink" title="1.2.5 zip函数"></a>1.2.5 zip函数</h4><p>zip    可以将多个列表、元组或其它序列成对组合成⼀个元组列表：</p><pre><code>    list1=[1,2,3,4]    list2 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]    list3 = zip(list1,list2)    print(list(list3))    结果：    [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;)]    print(dict(list3))    结果：    {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}</code></pre><h4 id="1-2-6-reversed函数"><a href="#1-2-6-reversed函数" class="headerlink" title="1.2.6 reversed函数"></a>1.2.6 reversed函数</h4><p>reversed    可以从后向前迭代⼀个序列：</p><pre><code>    list(reversed(range(10)))    结果：    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</code></pre><h3 id="1-3字典"><a href="#1-3字典" class="headerlink" title="1.3字典"></a>1.3字典</h3><p>字典就不想多说了，很多都是通用的，到用的时候在查吧。</p><h3 id="1-4集合"><a href="#1-4集合" class="headerlink" title="1.4集合"></a>1.4集合</h3><p>集合是⽆序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以⽤两种⽅式创 建集合：通过set函数或使⽤尖括号set语句：{1,2,3}</p><h4 id="1-4-1集合取并集"><a href="#1-4-1集合取并集" class="headerlink" title="1.4.1集合取并集"></a>1.4.1集合取并集</h4><p>合并是取两个集合中不重复的元素。可以⽤    union    ⽅法，或者    |    运算符</p><pre><code>    a = {1,2,3,4,5,6}    b = {3,4,5,7,8,9}    a|b    结果：    {1, 2, 3, 4, 5, 6, 7, 8, 9}</code></pre><h4 id="1-4-2集合取交集"><a href="#1-4-2集合取交集" class="headerlink" title="1.4.2集合取交集"></a>1.4.2集合取交集</h4><p>交集的元素包含在两个集合中。可以⽤    intersection    或    &amp;    运算符：</p><pre><code>    a&amp;b    结果：    {3, 4, 5}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析系列-1</title>
    <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-1/"/>
    <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据分析第一课-数据分析过程与方法论"><a href="#一、数据分析第一课-数据分析过程与方法论" class="headerlink" title="一、数据分析第一课-数据分析过程与方法论"></a>一、数据分析第一课-数据分析过程与方法论</h1><a id="more"></a><h2 id="1-数据分析六部曲"><a href="#1-数据分析六部曲" class="headerlink" title="1.数据分析六部曲"></a>1.数据分析六部曲</h2><p>数据分析基本过程：数据收集-数据处理-根据分析目的和思路进行数据分析-分析结果图标展示-撰写分析报告    </p><h2 id="2-数据分析方法论"><a href="#2-数据分析方法论" class="headerlink" title="2.数据分析方法论"></a>2.数据分析方法论</h2><hr><p>方法论就是指导进行数分析的方法，你的数据分析需要有理论基础来支撑，这就是方法论。<br>常用的方法论有：<br>营销方面：4P、用户使用行为、STP理论、SWOT理论等<br>管理方面：PEST、5W2H、时间管理、生命周期、逻辑树、金字塔、SMART原则等。</p><h3 id="2-1-PEST分析法"><a href="#2-1-PEST分析法" class="headerlink" title="2.1 PEST分析法"></a>2.1 PEST分析法</h3><p>PEST分析法主要针对宏观环境的分析<br>就是对政治、经济、技术和社会这四大类外部环境因素进行分析。<br><img src="/img/pest.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-2-5W2H分析法"><a href="#2-2-5W2H分析法" class="headerlink" title="2.2 5W2H分析法"></a>2.2 5W2H分析法</h3><p>5W2H方法可以用在当你逻辑不清晰时，可用这几个方面来进行分析。<br>何因、何事、何时、何人、何地、如何做、何价 这七个方面进行分析。<br><img src="/img/5w2h.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-逻辑树分析法"><a href="#2-3-逻辑树分析法" class="headerlink" title="2.3 逻辑树分析法"></a>2.3 逻辑树分析法</h3><p>逻辑树分析法用在当一个问题比较明确，期望通过分析来找到问题所在，解决关键问题。<br>就是将引起一个问题的原因进行一级一级的罗列，进行拆分。<br><img src="/img/luojishu.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-4-4P营销理论"><a href="#2-4-4P营销理论" class="headerlink" title="2.4 4P营销理论"></a>2.4 4P营销理论</h3><p>4P营销理论主要运用在了解公司整体运营情况上，以此来搭建公司整体运行框架<br>就是通过分析公司产品、价格、渠道、促销来分析公司目前的运营状况。<br><img src="/img/4p.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-5-用户行为理论"><a href="#2-5-用户行为理论" class="headerlink" title="2.5 用户行为理论"></a>2.5 用户行为理论</h3><p>用户行为理论是指用户对一个产品从认知、熟悉、试用、使用、忠诚的过程理论，对于一件产品或者一个网站，如果不清楚它目前在人群中的定位，就可以使用此理论。比如一个网站，目前他的ip、pv量指标很大但是平均停留市场很短，说明就是在认知阶段；如果平均停留时长很长，但注册用户并不多，说明是在熟悉阶段，，，以此类推，可以通过用户行为，找到产品在用户人群中的定位。如下图网站例子所示<br><img src="/img/yonghuxingwei.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、数据分析第二课-数据准备"><a href="#二、数据分析第二课-数据准备" class="headerlink" title="二、数据分析第二课-数据准备"></a>二、数据分析第二课-数据准备</h1><p>常言道，巧妇难为无米之炊，要想数据分析，首先要进行数据准备。</p><h2 id="1-理解数据"><a href="#1-理解数据" class="headerlink" title="1.理解数据"></a>1.理解数据</h2><h3 id="1-1字段与记录"><a href="#1-1字段与记录" class="headerlink" title="1.1字段与记录"></a>1.1字段与记录</h3><p>字段是事物或者现象的某种特征，比如学号、名字，在统计学中称为变量<br>记录是事物或现象某种特征的具体体现，比如成绩是“85”，性别为“男”，记录也称为数据或变量值。<br>字段和记录就是键值对的关系。</p><h3 id="1-2数据类型"><a href="#1-2数据类型" class="headerlink" title="1.2数据类型"></a>1.2数据类型</h3><p>数据类型总体有两种，字符型和数值型</p><h3 id="1-3数据表"><a href="#1-3数据表" class="headerlink" title="1.3数据表"></a>1.3数据表</h3><p>一维表和二维表，如图<br>区分一维表和二维表：一维表中的数值，如2006、2007等都是属于字段“年份”的，也就是说，同一列的数据，从第二行开始往下的数据都是属于第一行的范畴的，比如“北京”属于“地区”；而二维表7861，不属于“2006”，也不属于“北京”，而是同时代表了“2006”年的“北京”的Gdp，同时代表的三样事物。这就是区别，如下图<br><img src="/img/yiweierweibiao.png" srcset="/img/loading.gif" alt=""><br>具体怎么实现一维表和二维表的转换，百度就行</p><h1 id="三、数据处理"><a href="#三、数据处理" class="headerlink" title="三、数据处理"></a>三、数据处理</h1><p>由于《谁说菜鸟不会数据分析》这本书都是用excel做的，所以这本书就没有多大学习的必要了。下一阶段就从数据处理就是学习pandans了</p>]]></content>
    
    
    
    <tags>
      
      <tag>data analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>birthday</title>
    <link href="/2020/03/24/birthday/"/>
    <url>/2020/03/24/birthday/</url>
    
    <content type="html"><![CDATA[<p>生日快乐，张弟弟!</p><a id="more"></a><p>今天,23了，他们说<br>23和24是完全不同的两个年龄，23可能啥也不知道，24就感觉时间飞逝了，毕竟活了整整两个轮回了呢<br>大家都在好好的工作了，终于到了自己找工作的时候了，有点怕，也有点期待。<br>向着自己喜欢的职业，还是有时间在努力一下的呢<br>嗝~<br>今天吃的有点饱，一会出去打会球吧<br>张弟弟，你要加油啊<br>加油变强，变帅，变的更加无所畏惧<br>这是你的第24年了，加油！<br>打会球，回来再keep吧，<br>冲啊<br>张弟弟！！！！！！！！！！！！！！！！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>daily life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test1</title>
    <link href="/2020/03/23/test1/"/>
    <url>/2020/03/23/test1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>newlife</title>
    <link href="/2020/03/11/newlife/"/>
    <url>/2020/03/11/newlife/</url>
    
    <content type="html"><![CDATA[<p>我分手了，谈了咋算也有四年了的恋爱，结束了。。。</p><a id="more"></a><p>思索良久，考虑再三，决定和你了分手，对不起，几年的异地，我输在了终点。<br>你说，我为啥呢，我凭啥呢？我也不知道啊，你给了我青春，我又何尝不是呢，我跟之前那么要好的朋友的都不联系了，<br>我，早已不再是我了<br>说实话，这几年，我从来没有深深的反思过自己，堕落如此，为何？<br>不是因为你，是因为我，我太在意你，太在意爱的人，我都忘了我自己了，我都忘了，最该爱的，除了父母亲人，本应该是自己了<br>你给了我青春，我也给了你的，爱你时，我用尽全力，可是，我得到了什么呢<br>相信分手后，大家都会骂我渣男的，是的，我是很渣，是的吧，天生的我也没办法<br>忽然有一天，哪一天呢？记不清了，大概是她考完研的某天<br>我看了一下自己，遍体鳞伤，为什么呢<br>这么多年了，我都没好好的爱自己啊，<br>我太重视在乎的人感受了，<br>其实<br>真的是不值得啊<br>哈哈<br>谈着恋爱，心里却始终是感觉一个人，我问过自己，我也给了自己答案，可能你不太会爱一个人吧，可能我也不会吧<br>爱你时候很爱，心无旁骛，因为心太满，都是你，但是当我看见别的情侣之间那种感觉，我愣住了，我这几年是在谈恋爱么，，，<br>这次<br>心<br>真的累了<br>对不起，没有给你甜甜的恋爱，我太直了，<br>我想好好爱一下自己，不然以后有了自己的家，更没时间爱自己了，哈哈<br>对不起啊，家里可能没有你了，你要好好的啊</p><p>还是决定重启我的博客，多多审视自己的内心，希望坚持下去，人那，毕竟是自己活着，<br>敬自己！</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlday1</title>
    <link href="/2019/10/31/mlday1/"/>
    <url>/2019/10/31/mlday1/</url>
    
    <content type="html"><![CDATA[<p>机器学习入门</p><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h2 id="略略略"><a href="#略略略" class="headerlink" title="略略略"></a>略略略</h2><p>字典特征值转化为二维数组/矩阵<br>首先需要知道得到的结果是value而不是key，key在结果中并没有显示。而在此处，二者分别用特征名和特征值来代替。<br>-先用两个字典，他们的value都是数字：</p><pre><code>    dic1 = [{&#39;地区&#39;:100,&#39;温度&#39;:200},{&#39;地区&#39;:200,&#39;温度&#39;:400}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[100. 200.]     [200. 400.]]</code></pre><p>可以看到，他将字典的value值，通过矩阵或者说二维数组的形式表示出来了。<br>-再将字典的value变成字符串：</p><pre><code>    dic1 = [{&#39;1&#39;:&#39;100&#39;,&#39;温度&#39;:200},{&#39;1&#39;:&#39;200&#39;,&#39;温度&#39;:400}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[  1.   0. 200.]     [  0.   1. 400.]]</code></pre><p>可以看到，后面的200、400仍然不变，但是前面的string的value值被两个1hot编码给代替了，<br>-再将后面的value值也变成字符串：</p><pre><code>    dic1 = [{&#39;1&#39;:&#39;100&#39;,&#39;温度&#39;:&#39;200&#39;},{&#39;1&#39;:&#39;200&#39;,&#39;温度&#39;:&#39;400&#39;}]    transfer1 = DictVectorizer(sparse=False)    data1 = transfer1.fit_transform(dic1)    print(&quot;全是数字的特征:\n&quot;,data1)结果：    全是数字的特征:     [[1. 0. 1. 0.]     [0. 1. 0. 1.]]</code></pre><p>结果是两个value都变成了1hot编码来代替。<br>就是，当特征值为类别（string）时，就会使用1hot编码。<br>-前面输出的都是特征值，下面输出特征名字：</p><pre><code>        dic1 = [{&#39;数字&#39;:&#39;100&#39;,&#39;温度&#39;:200},{&#39;数字&#39;:&#39;200&#39;,&#39;温度&#39;:400}]        transfer1 = DictVectorizer(sparse=False)        data1 = transfer1.fit_transform(dic1)        #print(&quot;全是数字的特征:\n&quot;,data1)        print(&quot;特征名字：\n&quot;,transfer1.get_feature_names())    结果：        全是数字的特征:         [[  1.   0. 200.]         [  0.   1. 400.]]        特征名字：         [&#39;数字=100&#39;, &#39;数字=200&#39;, &#39;温度&#39;]</code></pre><p>从名字可以看出，第一列表示“数字=100”，如果你是，就是1；不是，就是0；第二列表示“数字=200”；第三列表示“温度”。以此类推。。。<br>文本特征值转化二位数组</p><hr><p>就是将一段文本的每个单词作为一个特征，统计该单词出现的次数</p><pre><code>    data = [&#39;life is short,i like like python&#39;,&#39;life is too long ,i dislike python&#39;]    transfer = CountVectorizer()    datanew = transfer.fit_transform(data)    print(&quot;运行结果:\n&quot;,datanew.toarray())    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())结果：    运行结果:     [[0 1 1 2 0 1 1 0]     [1 1 1 0 1 1 0 1]]    特征名字：     [&#39;dislike&#39;, &#39;is&#39;, &#39;life&#39;, &#39;like&#39;, &#39;long&#39;, &#39;python&#39;, &#39;short&#39;, &#39;too&#39;]</code></pre><p>中文文本特征</p><pre><code>    data = [&#39;人生苦短,啦啦啦&#39;,&#39;我我用Python&#39;]    transfer = CountVectorizer()    datanew = transfer.fit_transform(data)    print(&quot;运行结果:\n&quot;,datanew.toarray())    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())结果：    运行结果:     [[1 1 0]     [0 0 1]]    特征名字：     [&#39;人生苦短&#39;, &#39;啦啦啦&#39;, &#39;我我用python&#39;]</code></pre><p>可以看到中文文本的结果依据逗号来断句，哈哈哈哈哈。然后介绍一个自动中文分词的库，jieba，可以根据中文的词组规范，自动进行分词，比如“我爱北京天安门”—&gt;“我 爱 北京 天安门”，然后在输出特征就可以了。</p><pre><code>        data = [&#39;我爱北京天安门&#39;, &#39;我和我亲爱的祖国&#39;]        new_list = []        for i in data:            data1 = &quot; &quot;.join(list(jieba.cut(i)))            new_list.append(data1)        print(new_list)    结果：        [&#39;我 爱 北京 天安门&#39;, &#39;我 和 我 亲爱 的 祖国&#39;]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又是建模的一天</title>
    <link href="/2019/10/19/%E5%8F%88%E6%98%AF%E5%BB%BA%E6%A8%A1%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <url>/2019/10/19/%E5%8F%88%E6%98%AF%E5%BB%BA%E6%A8%A1%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>今天也是建模的一天，但是呢，出现了很大的问题，我也不知道这个问题是不是由于人为因素出现的，但是呢，还是好难受啊。<br>跟室友喝了顿酒，还是好多了。<br>为什么总是觉得做的不够，大概是因为心中有所期待吧。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池的join用法</title>
    <link href="/2019/10/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0join%E7%94%A8%E6%B3%95/"/>
    <url>/2019/10/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0join%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>承接上篇关于线程池的join用法  ^_^   这图真不错，竟然也成了找图专业户了</p><a id="more"></a><h2 id="threading线程池"><a href="#threading线程池" class="headerlink" title="threading线程池"></a>threading线程池</h2><p>今天一直在查关于线程池的用法，因为线程池是创建线程之后，当不使用的时候就放在线程池里面而不会销毁，相比于创建线程又销毁线程减少了不少时间。但是搜了好多，试了好多，依然没有啥具体的结果。<br>但是搜到了一篇threading+queue创建线程池的做法，就是上一盘文章的用法，所以本文对其进行扩充，主要为增加join的用法。</p><ol><li><p>没有加入join结果：</p><pre><code> import time from fake_useragent import UserAgent as ua import requests from queue import Queue import threading def get_url(url_queue):     while url_queue.qsize() &gt; 0:         url =  url_queue.get()         headers = {&quot;User-Agent&quot;: ua().Chrome}         response = requests.get(url=url, headers=headers, timeout=10)         print(threading.current_thread().name)         print(&quot;访问了：&quot;,url) def get_queue():     url_queue = Queue()     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://www.baidu.com&quot;,                 &quot;http://www.jd.com&quot;,                 &quot;http://www.sina.com&quot;,                 &quot;http://zzzspider.top&quot;,                 ]     for url in url_list:         url_queue.put(url)     return url_queue if __name__ == &#39;__main__&#39;:     print(threading.current_thread().name)     url_queue = get_queue()     for i in range(3):         th = threading.Thread(target=get_url,args=(url_queue,))         th.start()     print(&quot;task done&quot;)</code></pre><p>运行结果：</p><pre><code> MainThread task done Thread-3 访问了： http://www.jd.com Thread-3 访问了： http://www.sina.com Thread-2 访问了： http://www.baidu.com Thread-1 访问了： http://film.qq.com Thread-3 访问了： http://zzzspider.top</code></pre><p>可以看出，想在所有线程结束之后打印出task done的作用没有实现，因为主线程不管子线程，只要运行结束就结束了，但是此时子线程仍然在运行，所以打印内容随着主线程结束之后就输出了。</p></li><li><p>加入join()第一次尝试：仅修改主函数部分</p><pre><code> if __name__ == &#39;__main__&#39;:     print(threading.current_thread().name)     url_queue = get_queue()     for i in range(3):         th = threading.Thread(target=get_url,args=(url_queue,))         th.start()         th.join()     print(&quot;task done&quot;)</code></pre><p>运行及结果：</p><pre><code> MainThread Thread-1 访问了： http://film.qq.com Thread-1 访问了： http://www.baidu.com Thread-1 访问了： http://www.jd.com Thread-1 访问了： http://www.sina.com Thread-1 访问了： http://zzzspider.top task done</code></pre><p>虽然实现了task done在主线程结束之后在输出， 但是可以看出此时只有一个线程在执行。。</p></li><li><p>第二次尝试：</p><pre><code> for i in range(3):     th = threading.Thread(target=get_url,args=(url_queue,))     th.start() th.join()</code></pre><p>这次运行结果就可以了，但是多运行了几次之后发现，仍然会偶发性的产生主线程较早结束的情况。</p></li><li><p>创建一个线程池函数，然后在主线程中调用：</p><pre><code> import time from fake_useragent import UserAgent as ua import requests from queue import Queue import threading def get_url(url_queue):     while url_queue.qsize() &gt; 0:         url =  url_queue.get()         headers = {&quot;User-Agent&quot;: ua().Chrome}         response = requests.get(url=url, headers=headers, timeout=10)         print(threading.current_thread().name)         print(threading.current_thread().is_alive())         print(&quot;访问了：&quot;,url) def get_queue():     url_queue = Queue()     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://www.baidu.com&quot;,                 &quot;http://www.jd.com&quot;,                 &quot;http://www.sina.com&quot;,                 &quot;http://zzzspider.top&quot;,                 ]     for url in url_list:         url_queue.put(url)     return url_queue def th_list():     th_list = []     for i in range(4):         th = threading.Thread(target=get_url,args=(url_queue,))         th_list.append(th)     return th_list if __name__ == &#39;__main__&#39;:     for i in range(10):         print(threading.current_thread().name)         url_queue = get_queue()         th_list1 = th_list()         for th in th_list1:             th.start()         th.join()         print(&quot;task done&quot;)         print(th.is_alive())</code></pre><p>运行结果，比3好多了，但是！！！还有很小概率的出现那个情况。。。。属实不知道为什么。。。</p></li><li><p>终极版<br>修改4的代码：</p><pre><code> if __name__ == &#39;__main__&#39;:     for i in range(10):         print(threading.current_thread().name)         url_queue = get_queue()         th_list1 = th_list()         for th in th_list1:             th.start()         for th in th_list1:             th.join()         print(&quot;task done&quot;)         print(th.is_alive())</code></pre><p>然后循环了10次，没出现错误的情况，，，虽然成功了，但是不知道为什么。。。懵逼中</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>join用法</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于threading多线程与tomorrow协程爬虫的一些对比</title>
    <link href="/2019/10/14/1014.html/"/>
    <url>/2019/10/14/1014.html/</url>
    
    <content type="html"><![CDATA[<p>记录一下threading构造多线程请求的基本语法，以及关于tomorrow协程爬虫的基本语法，并且对比一下二者的效率^…^,</p><a id="more"></a><hr><h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><ol><li><p>刚开始使用threading的时候与requests配合使用，但是每次都会出现重复请求的情况，就是虽然产生了多线程执行，但是每次多线程都请求相同的内容，最终发现是因为使用for循环来获取一个list中的url出的问题。不应该直接在list中获取url，而是先将list遍历存入到队列queue中，因为queue是一个队列，存在先入先出原则，而且等于说第一个数被拿出去了，就没有了，你再从中取值的话，就只能取第二个数，所以这样就使得不会产生重复的情况。下面是实现的语法。</p></li><li><p>threading+requests的用法：<br>(1) 首先需要定义一个队列函数：</p><pre><code> def url_queue():     list = [1,2,....]     for i in url_list:         url_queue.put(i) return url_queue</code></pre><p>结果可以得到一个队列：url_queue<br>(2) 定义一个requests函数：</p><pre><code> def get_html(url_queue):     while url_queue.qsize() &gt; 0:         url = url_queue.get()         response = requests.get(url=url,headers = headers,timeout = 10)         response.encoding = &#39;utf-8&#39;         response = response.text         print(response)     print(&quot;总用时:&quot;,time.time()-star_time)       #测试运行时间</code></pre><p>注意几个点：1是队列循环while，当然用for理论上也可以的，然后是编码问题。当我print网页内容时候，发现中文乱码，原因是网站的编码格式和Python解释器的格式不一样造成的，所以可以将responds进行编码’utf-8’，然后就可以输出内容了。<br>(3) 定义一个线程函数：</p><pre><code> def th_list():     thr_list = []     for i in range(5):         t_get = threading.Thread(target=get_html,args=(url_queue,))         thr_list.append(t_get)     return thr_list</code></pre><p>这一步的目的就是要构建一个线程的列表，以便于一会主函数调用，注意在targ参数中传入函数名，args参数中传入变量。<br>(4) 主函数：</p><pre><code> if __name__ == &#39;__main__&#39;:     star_time = time.time()   #测定运行时间     url_queue = url_queue()   #得到url队列     thr_list = th_list()      #调用创建线程函数，此时创建了一个具有n个线程的线程列表     for th in thr_list:          #遍历线程，实际上多线程就发生在这一步中，当上一个线程io操作时，         th.start()              #就会调用线程列表中的其他闲置线程运行。</code></pre><p>(5) 完整代码如下：</p><pre><code> import threading import requests from fake_useragent import UserAgent as ua from queue import Queue import time #coding:utf-8 headers = {&quot;User-Agent&quot;: ua().Chrome} url_queue = Queue() def get_url():     url_list = [&quot;http://film.qq.com&quot;,                 &quot;http://film.qq.com&quot;,                 &quot;http://film.qq.com&quot;,                 ]     for i in url_list:         url_queue.put(i)     return url_queue def get_html(url_queue):     while url_queue.qsize() &gt; 0:         url = url_queue.get()         response = requests.get(url=url,headers = headers,timeout = 10)         response.encoding = &#39;utf-8&#39;         response = response.text         print(response)     print(&quot;总用时:&quot;,time.time()-star_time) def th_list():     thr_list = []     for i in range(2):         t_get = threading.Thread(target=get_html,args=(url_queue,))         thr_list.append(t_get)     return thr_list if __name__ == &#39;__main__&#39;:     star_time = time.time()     url_queue = get_url()     thr_list = th_list()     for th in thr_list:         th.start()</code></pre></li></ol><hr><h2 id="tomorrow协程爬虫"><a href="#tomorrow协程爬虫" class="headerlink" title="tomorrow协程爬虫"></a>tomorrow协程爬虫</h2><h2 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h2><p>首先我们得知道协程是啥？协程其实可以认为是比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。</p><p>通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定<br>协程与线程？</p><hr><p>那么这个过程看起来比线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。<br>                                 （摘自—<a href="https://aceld.gitbooks.io/python/content/fu-wu-qi-mo-xing/xie-cheng.html）" target="_blank" rel="noopener">https://aceld.gitbooks.io/python/content/fu-wu-qi-mo-xing/xie-cheng.html）</a><br>通俗来讲，协程是线程的细分，实现功能和多线程差不多，(在深入理解日后再说）但是协程创建时间相比线程少，所以更加高效。<br>tomorrow</p><hr><p>实现代码如下：</p><pre><code>    import time    from requests_html import HTMLSession    from fake_useragent import UserAgent as ua    from tomorrow import threads    headers = {&quot;User-Agent&quot;: ua().Chrome}    session = HTMLSession()    url_list = [&quot;http://film.qq.com&quot;,                &quot;http://film.qq.com&quot;,]    @threads(2)    def async_get_req(url, timeout=10):        try:            req = session.get(url, headers=headers, timeout=timeout)            return req        except:            pass    def get_link(req_list):        for req in req_list:            try:                print(req.html.text)            except:                pass    if __name__ == &#39;__main__&#39;:        start2 = time.time()        req_list = []        for url in url_list:            req = async_get_req(url)            req_list.append(req)        get_link(req_list)        end2 = time.time()        print(&quot;并发后花费时间&quot;, end2 - start2)</code></pre><p>在构建过程中，唯一出现的问题就是，如果将上述两个函数合并为一个函数的话，协程就不会生效：</p><pre><code>    req_list = []        for url in url_list:            req = async_get_req(url)            req_list.append(req)            print(req.html.links)  #就是删除get_link函数，使其在此处实现，结果是不能协程执行，函数一个一个执行</code></pre><p>之后进行修改：</p><pre><code>    req_list = []    for url in url_list:        req = async_get_req(url)        req_list.append(req)            for i in req_list：                print(req.html.links)</code></pre><p>竟然就可以工作了，不知道为什么。。。<br>注意的地方就是，要创建多少线程，只要在函数前添加   @threads(2)  即可，方便，简单，高效。还有就是引入from requests_html import HTMLSession这个库，可以直接在网页获取之后就将其解析出来。十分方便。<br>最后通过运行时间对比，发现当线程数量和协程数量调大之后，多线程运行效率高于协程；而数量较小时候，协程效率高于多线程。灵活运用喽。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>多线程</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程与多进程</title>
    <link href="/2019/10/07/1007duoxiancheng.html/"/>
    <url>/2019/10/07/1007duoxiancheng.html/</url>
    
    <content type="html"><![CDATA[<p>关于Python多线程与多进程的一些自己理解的想法</p><a id="more"></a><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。<br>什么是线程？</p><hr><p>线程是指进程内的一个执行单元,也是进程内的可调度实体. 线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>看不太懂吧。可以做一个比喻，进程就是我们打开了一个ＱＱ，然后我们可以同时发消息，同时看空间，这就是多个线程。即进程是由系统调度的基本单位，而线程是进程内的执行单元。<br>进程和线程的发展史</p><hr><p>１.单进程，最初计算机是为了执行代码，就是每次只能执行一个程序，只有当这个程序执行完毕，才能执行下一个，比如要是聊ＱＱ就不能听歌。</p><p>２.多进程，为了提高使用效率，充分利用ｃｐｕ，就将内存划分成不同的块，每一个块就是一个进程，不同的程序放在不同的块里面，那么怎么能让这些程序同时执行呢？这就出现了“时间片轮转调度”，就是对于不同的进程，为其分配一个时间段，称为时间片，即该进程允许的时间。而ｃｐｕ呢就在这几个进程之间不断切换，很明显的是这几个进程也不是并行执行（也就是同时执行）的，但是对于ｃｐｕ来说，他的运算速度太快了，进程之间的切换快的对于人来说根本不可能察觉的到，所以对于人来说，在一秒内这几个进程都在执行，但实际上是ｃｐｕ在这一秒内对每个进程都执行了成百次的执行，才使得看起来同时执行。</p><p>３.多线程，时间片轮转调度是基于进程进行的，但是每个进程之下还可以进行细分。比如说我们打开一个ＱＱ，不仅可以聊天也可以看空间；所以对于进程又进行了细分：线程，这样一来ｃｐｕ的时间片轮转相当于又进行了细分，更加细腻，对每个线程划分时间片，ｃｐｕ在线程之间切换，使得运行更加丝滑，此时ｃｐｕ实际上是在线程之间进行切换。</p><p>４.多核，在计算上提高运行之后，越来越需要大量的计算，ｃｐｕ甚至有点不够用，此时影响的主要是硬件的能力，所以就发明了多核ｃｐｕ，每个核心可以相当于一个ｃｐｕ，独自执行一个或多个进程，当然同时就只有一个线程。这样才实现了实际意义上的并行执行。</p><p>5.对于多核ｃｐｕ来说，如果是<strong>计算密集型</strong>的使用多线程时计算速度比较快；如果是<strong>ＩＯ密集型</strong>的多线程的作用是当进程ｉｏ运算时的等待时间可以被其他线程使用，比如执行某个程序，程序运行过程，我们可以看到进度条也在增加。</p><p>6.何时使用多线程：切换线程和创建线程是需要时间的，当运算量较大，切换线程的时间可以被多线程运算节省的时间所填补，就是值得的，如果运算量较小，添加线程的时间大于运算节省的时间就是不合适的；但是对于特殊的ｉｏ操作，需要较多的等待时间，此时创建一个线程或者切换的时间将远远小于让线程等待的时间，所以此时让ｃｐｕ为其他线程服务，就可以充分的利用资源了。<br>Ｐｙｔｈｏｎ多线程和多进程</p><hr><p>Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。<br>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。<br>1.设置GIL。<br>2.切换到一个线程去执行。<br>3.运行。<br>4.把线程设置为睡眠状态。<br>5.解锁GIL。<br>6.再次重复以上步骤。<br>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。<br>Python多线程</p><hr><p>所以对于Ｐｙｔｈｏｎ程序来说，每时每刻都只有一个线程在执行，可以说对于多核ｃｐｕ来说完全没有发挥作用。如果没有必要的话，开启多线程反而会减少运行效率，为什么呢？比如说算一个程序１００００次，只用一个线程的话就是一万次计算；但是开启多线程的话，每运算１００次就会切换一个线程，在切换过程中呢，就会发生上述六个步骤，这时间增加量可想而知，所以对于Ｐｙｔｈｏｎ来说，如果是需要进行大量计算得话尽量不要使用多线程。<br>如果程序中需要大量ｉｏ操作，并且开启多线程的话，在Ｐｙｔｈｏｎ中当进行ｉｏ操作之前会主动释放ｇｉｌ，然后在某线程ｉｏ操作执行中，其他线程就可以获得ｇｉｌ，就可以执行其他程序。也就是说，当进程中出现需要等待（被动或者主动）程序的话，比如执行１次，等待１ｓ，再执行一次，等待一秒，一共重复五次，如果是单线程，共需要等待５ｓ；如果是多线程，在第一次等待的１ｓ里面，第二次执行，并且进行等待，第三次也在执行，并进行等待。。。五次运行，所有过程紧接在上一次运行后面进行，运行时间远远小于等待时间，也就是相当于５次同时执行，同时等待。这就等于单线程时间的１/５，以此来提升效率。<br>所以，如果是ｉｏ操作，等待时间较多的话，Ｐｙｔｈｏｎ多线程能够发挥较好的作用，并且多线程创建比多进程容易的多，所以建议用多线程。<br>Python多进程</p><hr><p>Ｐｙｔｈｏｎ还有一种提速，就是创建多进程。相当于将某个进程进行复制，然后创建一个新的进程来同时执行，这样的话，基本上可以是的计算能力翻倍，但是相应的创建进程时间远大于创建线程时间。<br>如果某个程序计算需求非常大，创建一个多进程可以有效的提高计算效率，此时创建多进程花费的时间就可以被提高的效率覆盖，此时合适。但是如果程序不需要太多的计算能力，创建多进程花费的时间反而小于带来的收益，此时是不合适的。<br>所以多ｉｏ操作的程序，基本上不会创建多进程；多计算能力的，多考虑多进程<br>总结</p><hr><p>Ｐｙｔｈｏｎ多ｉｏ操作，或者等待，使用多线程可以很好的提高效率，因此使用多线程可以很好的提高爬虫的运行效率（因为访问网页，下载网页，存储，上传等ｉｏ过程中，都会发生等待）<br>多计算密集型操作，使用多进程可以很好的提高效率<br>一定量的计算密集型操作，考虑创建销毁多进程花费的时间与带来的效率提升做对比，来选择是否创建多进程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>多线程多进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十一小结</title>
    <link href="/2019/10/07/1007suibi.html/"/>
    <url>/2019/10/07/1007suibi.html/</url>
    
    <content type="html"><![CDATA[<p>十一过完了，对近几天情况做一下总结吧，也对这几天没更新做一下jiantao-_-</p><a id="more"></a><p>十一那天，在哈汽看的阅兵，因为老师的项目比较紧，所以我们的工作时间就是放假和星期天。除了十月二号在实验室呆了一天，研究那个评论和阅读量统计，搞了整整一天，硬是没弄明白，头都要炸了。索性就全删了，啥也不弄了，就写点东西记录自己的心得体会，也作为一个自我纠错自我复习的静谧之地啪~<br>在这几天里，实际上一直想弄明白Python的多线程为什么那么鸡肋，但是一直没有时间，整整的二号一天时间都被可恶的评论统计给整没了，郁闷至极。然后其他时间要么就是六点回来睡到九点或者就是冻的脑袋疼，中间穿插几次聚餐（师兄分享会），所以呢，几乎晚上也没有时间来搞一搞这个东西，所以就同时更一下未了的心愿吧。<br>这几天在哈汽建模，其实也学到了挺多，一个是原来微晕公交车，到后来在上面玩手机一个小时没问题，我真是太容易融入环境了。。。再者就是做什么事都要细心哪，要知道身边人大家都很优秀，不是说超越谁，就是追赶也不得放松丝毫。这几天建模，确实刷新了我的一些认识，我觉得某些地方无法解决的问题，在我心里就觉得是图纸问题，因为五张A0，十几张A4难免会有失误，但是探讨之后，几乎所有的问题都迎刃而解，所以不懂的地方就多去问问别人啊！你以为人企业是吃啥饭的，图纸怎么可能有那么多问题呢，先从自己身上找问题吧。<br>所以说认真，渐渐的发现其实身边的所有人都有一个基本的素质，那就是细心，越是大的东西，你越要一点一滴自信斟酌，不要想当然，一定要先说服自己，但是还是那句话，不明白的多去问问别人，实在是太缺少团队协作能力了，这次和小组合作，确实也提升了不少这方面知识。认真<br>还想说点关于师兄分享的内容，一个说的是平时要多积累东西，增加见识面，然后工作中遇到类似的东西，可以不像别人那样惊叹，更加从容镇定，告诉老板这东西我知道。。。第二点就是业务，要知道怎么喝酒，喝酒的流程，怎么陪领导喝酒，也会得到领导的另眼相看。<br>另一个学长给我的感觉就是充分分析自身的情况，选择自己想要的工作，有自己的想法，管培生和公务员这方面都不好干，公务员可能某天突然就成了别人的炮灰了。目前形势比较好的就是研究所和一些大企业。</p><p>实际上，我是比较想转行做程序员的，为什么呢，我也想过这个问题，给自己的答案是，比较喜欢能干出实际东西的行业，比如写段程序直接就运行得到你要的结果了，而且实际的开销比较小，效益高，工资高，嘻嘻。当然梦想没实现就是梦想，如果一年后我真的签了程序员工组，一定会在这条路上越走越远，越快。<br>如果呢，梦想不能实现，那也没啥气馁的，至少还是很有盼头的，那样的话，我可能就去了南方的某个企业去做工业工程或者去洛阳613所当了一名为研究所贡献一生的普通人。<br>上面这段话就是我的找工作心里预期的排序。</p><p>好了，加油吧，认真点！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo添加“不蒜子”统计网站访问量</title>
    <link href="/2019/10/02/2processing/"/>
    <url>/2019/10/02/2processing/</url>
    
    <content type="html"><![CDATA[<p>添加网站访问量统计有多种方式，比如不蒜子、百度统计、谷歌统计、cnzz统计等<br>因为本主题为nexmoe，查看了配置文件中默认没有支持不蒜子统计，所以本文就对于添加不蒜子统计进行配置过程的记录</p><a id="more"></a><ol><li><p>安装不蒜子脚本</p><pre><code> &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; {% if theme.footer.counter %}            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>            <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>            <span class="post-meta-divider">|</span>            <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>        {% endif %}</code></pre></li></ol><p>将上述脚本复制到“\themes\nexmoe\layout_partial文件夹中的footers.ejs或者是（after-footers.ejs）文件(有的是swig文件）的尾部。<br>2. 修改themes主题下的_config.yml文件</p><pre><code>    # visitors count    counter: true</code></pre><ol start="3"><li><p>设置显示位置<br>（1）pv的方式，单个用户连续点击n篇文章，记录n次访问量：</p><pre><code> &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;     本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt;</code></pre></li></ol><p>（2）uv的方式，单个用户连续点击n篇文章，只记录1次访客数：</p><pre><code>    &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;      本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次    &lt;/span&gt;</code></pre><p>（3）将上述两个代码复制，放到headers中的最外层的div标签里面：</p><pre><code>    &lt;/div&gt;    &lt;div align=&quot;center&quot;&gt;        &lt;span id=&quot;busuanzi_container_site_pv&quot; align=&quot;center&quot;&gt;        本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次        &lt;/span&gt;        &lt;br&gt;        &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;        本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次        &lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- .nexmoe-drawer --&gt;</code></pre><p>要想让统计居中，添加一个div标签，设置为居中，将上述代码复制在其中。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome to zzzspider&#39;s blog</title>
    <link href="/2019/09/29/firstpage.html/"/>
    <url>/2019/09/29/firstpage.html/</url>
    
    <content type="html"><![CDATA[<p>无意之中看见通过github pages来搭建一个小网站的教程，竟然不用购买服务器，还有现成的网页模板可以使用，着实吃了一鲸<br>于是，今天就在欲望的驱动下，使用轮子，造一个网站吧。。。。。</p><a id="more"></a><p>（这里有一行注释。。。竟然占了一整行）<!--[![注释](https://i.loli.net/2019/09/29/RatxhS3zXopqi6H.gif)](https://www.baidu.com/ "导航")--><br>喵一眼时间，21：49：10<br>完了，一会得走了，先简短的对这个过程做个总结啪<del>~</del></p><ol><li><p>github账号有一个，然后创建一个仓库（用来当服务器鸭），设置域名为yourname.github.io</p></li><li><p>需要安装的如下：<br> –1. git  git是代码托管软件，github是代码托管平台，据说是同一个东西，只是呈现方式不同而已，就是用它的bush来实现代码传到github<br> –2. nodejs 是一个js的运行环境，就是前端的javascript，，因为hexo是基于nodejs编写，所以需要安装。。<br> –3. hexo  静态博客框架，你要是不想自己写一大堆html、css、js的话，就用他吧</p></li><li><p>具体操作过程包括但不限于：添加ssh到github上，把hexo部署到github上。。。<br> ssh是一种传输协议，用来实现文件传输，hexo部署到github上之后，就可以访问yourname.github.io，就可以看到你的hexo页面效果了。当然你也可以hexo server通过本地页面来观看效果。</p></li><li><p>设置个人域名。简单来说yourname.github.io相当于你的顶级域名，然后可以添加子域名比如zzzspider.top来访问，但是这个域名是要花钱滴~（阿里云新用户1元/年^_^，需要实名，不然不通，搞了一下午，实名之后可以了），然后呢添加域名解析（就是将zzzspider.top绑定到yourname.github.io的同一个ip上），ip查看就用ping就行；<br>然后在你的yourname.github.io上设置添加子域名。<br>这样两头都通了，那就通了，就可以使用zzzspider.io来查看你的网站辣。</p></li></ol><p>5.hexo的使用，先用hexo初始化一个文件夹，hexo init name,name就是文件夹名，然后在文件夹下npm install，之后就会创建一系列文件，就是你的hexo配置文件。之后需要什么操作就在里面改就行了，至于写文章hexo new title，创建一个文章，然后格式是md。</p><ol start="6"><li><p>部署呢就是：<br>hexo clean<br>hexo generate<br>hexo deploy<br>这样，你本地hexo啥样，部署到服务器就是啥样，所以写完可以现在本地看一下，然后在部署到服务器上，就更新了网站。</p></li><li><p>说了这么多，终于把步骤贴出来了，全过程参照但不局限于以下几个帖子：<br><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">铁子1</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzA4NDk3Nw==&mid=2457738181&idx=1&sn=0a204aa85ef7db1df0ff93c178121315&chksm=ff44b39bc8333a8d14adcec4df4c2bd305d67e0711526ade76f54d37a573e8d37efc0c4b64f6&mpshare=1&srcid=&sharer_sharetime=1569505999394&sharer_shareid=89617866ac20519a0a190ba9770a2185&from=timeline&scene=2&subscene=2&clicktime=1569766955&enterid=1569766955&ascene=2&devicetype=android-28&version=27000736&nettype=3gnet&abtest_cookie=BQABAAgACgALABIAEwAFAJ2GHgAjlx4AVpkeAMSZHgD2mR4AAAA%3D&lang=zh_CN&pass_ticket=sqlr5jMu3XGBDdmi30i7LUgwmLltDu85mROxvc9n8BxUB52MvrKMCWhUXlgbcz4m&wx_header=1" target="_blank" rel="noopener">铁子2</a><br>虽然只是一篇照葫芦画葫芦的文章，但是领悟力比较之前提高了一丢丢吧<br>good night    ^_^</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>welcome</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
